<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="徐鑫"><meta name="copyright" content="徐鑫"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>mysql | 徐鑫的笔记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"徐鑫的笔记","version":"1.10.6","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="基础篇SQL1.什么是SQL？     Structured Query Language：结构化查询语言     其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。      2.SQL通用语法     1. SQL 语句可以单行或多行书写，以分号结尾。     2. 可使用空格和缩进来增强语句的可读性。     3. MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql">
<meta property="og:url" content="http://example.com/2022/10/31/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/index.html">
<meta property="og:site_name" content="徐鑫的笔记">
<meta property="og:description" content="基础篇SQL1.什么是SQL？     Structured Query Language：结构化查询语言     其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。      2.SQL通用语法     1. SQL 语句可以单行或多行书写，以分号结尾。     2. 可使用空格和缩进来增强语句的可读性。     3. MySQL">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220606144953211.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220606145351734.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220606171518133.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220606173029853.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220606173722658.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220606180128967.png">
<meta property="og:image" content="https://hexo.xuxin.world/mysql/image-20220607170326819.png">
<meta property="og:image" content="https://hexo.xuxin.world/mysql/image-20220607172639423.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220607173942982.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220607224756131.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220607225025706.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220607230211908.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220607230506451.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220607230826013.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220607231021039.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220608000646347.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220608000758020.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220608001308148.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220609181121685.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220609181148669.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220609181210985.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220609191955401.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220611230435016.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220613021834174.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220613021847582.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220613023057649.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220613025941308.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220613030048567.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220613222348015.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220614010615268.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220614010919117.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220614011234113.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220620164103763.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220620170315495.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220620170930571.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220620171105766.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220620171422232.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220620171438199.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220620172159103.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220621132624873.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220621162235073.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220621163153114.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220622101706490.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220622104826321.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220622144220884.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220622151841459.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220622163256618.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220622163615173.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220622164125006.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220623092713677.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628223754338.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628224340402.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628224315561.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628231518331.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628231651860.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628231810340.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628231854778.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628232121270.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628232444533.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628232759934.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628232708998.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628233248849.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628233304222.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628233820501.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628234023488.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628234640756.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628234944579.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628235201813.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628235320598.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628235538984.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220628235633481.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629000323248.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629000358001.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629000638443.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629002311075.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629093836872.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629094116269.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629094621248.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629094823250.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629095747304.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629100215918.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629100315109.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629100402781.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629100529260.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629100630444.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629100842850.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629101204517.png">
<meta property="og:image" content="http://hexo.xuxin.world/mysql/image-20220629101426171.png">
<meta property="article:published_time" content="2022-10-31T01:55:35.827Z">
<meta property="article:modified_time" content="2022-11-03T03:41:52.218Z">
<meta property="article:author" content="徐鑫">
<meta property="article:tag" content="xuxin">
<meta property="article:tag" content="Blog">
<meta property="article:tag" content="徐鑫">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="徐鑫的笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hexo.xuxin.world/mysql/image-20220606144953211.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="徐鑫"><img width="96" loading="lazy" src="/images/touxiang2.jpg" alt="徐鑫"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">徐鑫</a></div><span class="site-name">徐鑫的笔记</span><sub class="site-subtitle"></sub><div class="site-description">记录每一天所学</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">22</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">14</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">12</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qun.qq.com/qqweb/qunpro/share?_wv=3&amp;_wwv=128&amp;appChannel=share&amp;inviteCode=28OEdR&amp;appChannel=share&amp;businessType=9&amp;from=246610&amp;biz=ka" title="QQ 频道 - 小云之家" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.yunyoujun.cn/img/about/white-qrcode-and-search.jpg" title="微信" target="_blank" style="color:#1AAD19"><span class="icon iconify" data-icon="ri:wechat-2-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:camera-fill"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL"><span class="toc-number">1.1.</span> <span class="toc-text">SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDL-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">DDL:操作数据库表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-%E5%A2%9E%E5%88%A0%E6%94%B9%E8%A1%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">DML:增删改表数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DQL-%E6%9F%A5%E8%AF%A2%E8%A1%A8%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">DQL:查询表记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DCL-%E7%94%A8%E6%88%B7-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.4.</span> <span class="toc-text">DCL:用户,权限管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">数值函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">日期函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">流程函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.3.</span> <span class="toc-text">约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.</span> <span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">多表关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">一对一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">一对多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">多对多</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">外连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">自连接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">联合查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2-%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.4.</span> <span class="toc-text">子查询(嵌套查询)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.</span> <span class="toc-text">事务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">进阶篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">2.1.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">mysql体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB"><span class="toc-number">2.1.2.</span> <span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM"><span class="toc-number">2.1.3.</span> <span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory"><span class="toc-number">2.1.4.</span> <span class="toc-text">Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">2.1.5.</span> <span class="toc-text">存储引擎的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">索引概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-tree-%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">B-tree:多路平衡查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-tree"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">B+tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E4%B8%ADB-tree"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">mysql中B+tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">Hash索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.3.</span> <span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">索引语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.2.5.</span> <span class="toc-text">SQL性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E9%A2%91%E6%AC%A1"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">查看执行频次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">mysql启动报错怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2profile"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">查询profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bexplain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">2.2.5.5.</span> <span class="toc-text">查看explain执行计划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.6.</span> <span class="toc-text">索引使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.2.7.</span> <span class="toc-text">索引设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.1.</span> <span class="toc-text">插入优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">主键优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%88%86%E8%A3%82"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">页分裂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%90%88%E5%B9%B6"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">页合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">主键设计原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#orderby%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.3.</span> <span class="toc-text">orderby优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#groupby%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.4.</span> <span class="toc-text">groupby优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limit%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.5.</span> <span class="toc-text">limit优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.6.</span> <span class="toc-text">count优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Update%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.7.</span> <span class="toc-text">Update优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.8.</span> <span class="toc-text">多表查询优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">存储对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">2.4.1.</span> <span class="toc-text">视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">游标与条件处理程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.3.</span> <span class="toc-text">存储函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">2.4.4.</span> <span class="toc-text">触发器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">2.5.2.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">2.5.3.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">元数据锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">意向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">2.5.4.</span> <span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">记录锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81-%E4%B8%B4%E9%97%B4%E9%94%81"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">间隙锁&#x2F;临间锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%BC%95%E6%93%8E"><span class="toc-number">2.6.</span> <span class="toc-text">InnoDB引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.1.</span> <span class="toc-text">逻辑存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">2.6.2.</span> <span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">内存架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%9E%B6%E6%9E%84"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">磁盘架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.6.2.3.</span> <span class="toc-text">后台线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.3.</span> <span class="toc-text">事务原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log"><span class="toc-number">2.6.3.1.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">2.6.3.2.</span> <span class="toc-text">undo log</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC"><span class="toc-number">2.6.4.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">隐式字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log-1"><span class="toc-number">2.6.4.2.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readview"><span class="toc-number">2.6.4.3.</span> <span class="toc-text">readview</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.5.</span> <span class="toc-text">事务原理总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mysql%E7%AE%A1%E7%90%86"><span class="toc-number">2.7.</span> <span class="toc-text">Mysql管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.7.1.</span> <span class="toc-text">系统数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql"><span class="toc-number">2.7.2.</span> <span class="toc-text">mysql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqladmin"><span class="toc-number">2.7.3.</span> <span class="toc-text">mysqladmin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlbinlog"><span class="toc-number">2.7.4.</span> <span class="toc-text">mysqlbinlog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlshow"><span class="toc-number">2.7.5.</span> <span class="toc-text">mysqlshow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqldump"><span class="toc-number">2.7.6.</span> <span class="toc-text">mysqldump</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysqlimport-source"><span class="toc-number">2.7.7.</span> <span class="toc-text">mysqlimport&#x2F;source</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">运维篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">3.1.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97"><span class="toc-number">3.1.1.</span> <span class="toc-text">错误日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="toc-number">3.1.2.</span> <span class="toc-text">二进制日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">3.1.3.</span> <span class="toc-text">查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97-1"><span class="toc-number">3.1.4.</span> <span class="toc-text">慢查询日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA"><span class="toc-number">3.2.3.</span> <span class="toc-text">搭建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mycat"><span class="toc-number">3.3.2.</span> <span class="toc-text">mycat</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mycat%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">mycat配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">垂直分库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%89%87%E8%A7%84%E5%88%99"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">分片规则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E5%88%86%E7%89%87"><span class="toc-number">3.3.2.3.1.</span> <span class="toc-text">范围分片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%96%E6%A8%A1%E5%88%86%E7%89%87"><span class="toc-number">3.3.2.3.2.</span> <span class="toc-text">取模分片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">3.3.2.3.3.</span> <span class="toc-text">一致性哈希</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.3.2.3.4.</span> <span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%8C%87%E5%AE%9A"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">应用指定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E7%89%87-hash%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.2.5.</span> <span class="toc-text">固定分片-hash算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E8%A7%A3%E6%9E%90"><span class="toc-number">3.3.2.6.</span> <span class="toc-text">字符串hash解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%A4%A9%E5%88%86%E7%89%87"><span class="toc-number">3.3.2.7.</span> <span class="toc-text">按天分片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%87%AA%E7%84%B6%E6%9C%88%E5%88%86%E7%89%87"><span class="toc-number">3.3.2.8.</span> <span class="toc-text">按自然月分片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mycat%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">3.3.3.</span> <span class="toc-text">mycat的管理与监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">3.4.</span> <span class="toc-text">读写分离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%B8%80%E4%B8%9B"><span class="toc-number">3.4.1.</span> <span class="toc-text">一主一丛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E"><span class="toc-number">3.4.2.</span> <span class="toc-text">双主双从</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">4.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">4.1.</span> <span class="toc-text">AOP记录日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">系统性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84ORDER-BY-field"><span class="toc-number">4.3.</span> <span class="toc-text">MySQL中的ORDER BY field</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">配置文件参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.5.</span> <span class="toc-text">事件(定时任务)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">4.6.</span> <span class="toc-text">分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E4%B8%BB%E9%94%AE"><span class="toc-number">4.7.</span> <span class="toc-text">复合主键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.</span> <span class="toc-text">其他函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-number">4.9.</span> <span class="toc-text">其他指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.9.1.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">4.9.2.</span> <span class="toc-text">数据表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.9.3.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-1"><span class="toc-number">4.9.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSV%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.10.</span> <span class="toc-text">CSV存储引擎的使用</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/10/31/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="徐鑫"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="徐鑫的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">mysql</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2022-10-31 09:55:35" itemprop="dateCreated datePublished" datetime="2022-10-31T09:55:35+08:00">2022-10-31</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2022-11-03 11:41:52" itemprop="dateModified" datetime="2022-11-03T11:41:52+08:00">2022-11-03</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">数据库</span></a></span></span></div><div class="post-author"><span class="author-name">徐鑫</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body">
<div class="markmap-container" style="height:500px">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;基础&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;SQL&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;函数&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;约束&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;多表查询&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;事务&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;进阶&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;存储引擎&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;索引&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;SQL优化&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;存储对象&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;锁&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;InnoDB引擎&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;Mysql管理&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;原理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;日志&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;主从复制&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;分库分表&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;读写分离&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;其他&quot;}],&quot;p&quot;:{}}"></svg>
</div>



<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a><strong>基础篇</strong></h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a><strong>SQL</strong></h2><pre><code>1.什么是SQL？
    Structured Query Language：结构化查询语言
    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。
    
2.SQL通用语法
    1. SQL 语句可以单行或多行书写，以分号结尾。
    2. 可使用空格和缩进来增强语句的可读性。
    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。
    4. 3 种注释
        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
        * 多行注释: /* 注释 */
    
3. SQL分类
    1) DDL(Data Definition Language)数据定义语言
        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等
    2) DML(Data Manipulation Language)数据操作语言
        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等
    3) DQL(Data Query Language)数据查询语言
        用来查询数据库中表的记录(数据)。关键字：select, where 等
    4) DCL(Data Control Language)数据控制语言(了解)
        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等
</code></pre>
<h3 id="DDL-操作数据库表"><a href="#DDL-操作数据库表" class="headerlink" title="DDL:操作数据库表"></a><strong>DDL:操作数据库表</strong></h3><pre><code>1. 操作数据库：CRUD
    1. C(Create):创建
        * 创建数据库：
            * create database 数据库名称;
        * 创建数据库，判断不存在，再创建：
            * create database if not exists 数据库名称;
        * 创建数据库，并指定字符集
            * create database 数据库名称 character set 字符集名;

        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk
            * create database if not exists db4 character set gbk;
    2. R(Retrieve)：查询
        * 查询所有数据库的名称:
            * show databases;
        * 查询某个数据库的字符集:查询某个数据库的创建语句
            * show create database 数据库名称;
    3. U(Update):修改
        * 修改数据库的字符集
            * alter database 数据库名称 character set 字符集名称;
    4. D(Delete):删除
        * 删除数据库
            * drop database 数据库名称;
        * 判断数据库存在，存在再删除
            * drop database if exists 数据库名称;
    5. 使用数据库
        * 查询当前正在使用的数据库名称
            * select database();
        * 使用数据库
            * use 数据库名称;


2. 操作表
    1. C(Create):创建
        1. 语法：
            create table 表名(
                列名1 数据类型1,
                列名2 数据类型2,
                ....
                列名n 数据类型n
            );
            * 注意：最后一列，不需要加逗号（,）
            * 数据库类型：
                1. int：整数类型
                    * age int,
                2. double:小数类型
                    * score double(5,2)
                3. date:日期，只包含年月日，yyyy-MM-dd
                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss
                5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss    
                    * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值
                6. varchar：字符串
                    * name varchar(20):姓名最大20个字符
                    * zhangsan 8个字符  张三 2个字符
                    
        * 创建表
            create table student(
                id int,
                name varchar(32),
                age int ,
                score double(4,1),
                birthday date,
                insert_time timestamp
            );
        * 复制表：
            * create table 表名 like 被复制的表名;          
    2. R(Retrieve)：查询
        * 查询某个数据库中所有的表名称
            * show tables;
        * 查询表结构
            * desc 表名;
    3. U(Update):修改
        1. 修改表名
            alter table 表名 rename to 新的表名;
        2. 修改表的字符集
            alter table 表名 character set 字符集名称;
        3. 添加一列
            alter table 表名 add 列名 数据类型;
        4. 修改列名称 类型
            alter table 表名 change 列名 新列别 新数据类型;
            alter table 表名 modify 列名 新数据类型;
        5. 删除列
            alter table 表名 drop 列名;
    4. D(Delete):删除
        * drop table 表名;
        * drop table  if exists 表名 ;
</code></pre>
<h3 id="DML-增删改表数据"><a href="#DML-增删改表数据" class="headerlink" title="DML:增删改表数据"></a><strong>DML:增删改表数据</strong></h3><pre><code>1. 添加数据：
    * 语法：
        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);
    * 注意：
        1. 列名和值要一一对应。
        2. 如果表名后，不定义列名，则默认给所有列添加值
            insert into 表名 values(值1,值2,...值n);
        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来
2. 删除数据：
    * 语法：
        * delete from 表名 [where 条件]
    * 注意：
        1. 如果不加条件，则删除表中所有记录。
        2. 如果要删除所有记录
            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作
            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。
3. 修改数据：
    * 语法：
        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];

    * 注意：
        1. 如果不加任何条件，则会将表中所有记录全部修改。
</code></pre>
<h3 id="DQL-查询表记录"><a href="#DQL-查询表记录" class="headerlink" title="DQL:查询表记录"></a><strong>DQL:查询表记录</strong></h3><pre><code>* select * from 表名;

1. 语法：
    select       4
        字段列表
    from         1
        表名列表
    where        2
        条件列表
    group by     3
        分组字段
    having       3
        分组之后的条件
    order by     5
        排序
    limit        6
        分页限定

2. 基础查询
    1. 多个字段的查询
        select 字段名1，字段名2... from 表名；
        * 注意：
            * 如果查询所有字段，则可以使用*来替代字段列表。
    2. 去除重复：
        * distinct
    3. 计算列
        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null
            * 表达式1：哪个字段需要判断是否为null
            * 如果该字段为null后的替换值。
    4. 起别名：
        * as：as也可以省略

3. 条件查询
    1. where子句后跟条件
    2. 运算符
        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;
        * BETWEEN...AND  （最小最大全包）
        * IN( 集合) 
        * LIKE：模糊查询
            * 占位符：
                * _:单个任意字符
                * %：多个任意字符
        * IS NULL  
        * and  或 &amp;&amp;
        * or  或 || 
        * not  或 !

4. 聚合函数：将一列数据作为一个整体，进行纵向的计算。
    1. count：计算个数
        1. 一般选择非空的列：主键
        2. count(*)
    2. max：计算最大值
    3. min：计算最小值
    4. sum：计算和
    5. avg：计算平均值
* 注意：聚合函数的计算，排除null值。
    解决方案：
    1. 选择不包含非空的列进行计算
    2. IFNULL函数

5. 分组查询:
    1. 语法：group by 分组字段；
    2. 注意：
        1. 分组之后查询的字段：分组字段、聚合函数
        2. where 和 having 的区别？
            1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来
            2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。

6. 排序查询
    * 语法：order by 子句
        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...
    * 排序方式：
        * ASC：升序，默认的。
        * DESC：降序。
    * 注意：
        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。

7. 分页查询
    1. 语法：limit 开始的索引,每页查询的条数;
    2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数
</code></pre>
<h3 id="DCL-用户-权限管理"><a href="#DCL-用户-权限管理" class="headerlink" title="DCL:用户,权限管理"></a><strong>DCL:用户,权限管理</strong></h3><ol>
<li><p>用户管理</p>
<pre><code> 1. 添加用户：
     * 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;
 2. 删除用户：
     * 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;
 3. 修改用户密码：
     
     UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;
     UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;
     
     SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);
     SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);

     * mysql中忘记了root用户的密码？
         1. cmd -- &gt; net stop mysql 停止mysql服务
             * 需要管理员运行该cmd

         2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
         3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
         4. use mysql;
         5. update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;;
         6. 关闭两个窗口
         7. 打开任务管理器，手动结束mysqld.exe 的进程
         8. 启动mysql服务
         9. 使用新密码登录。
 4. 查询用户：
     -- 1. 切换到mysql数据库
     USE myql;
     -- 2. 查询user表
     SELECT * FROM USER;
</code></pre>
</li>
<li><p>权限管理：</p>
<pre><code> 1. 查询权限：
     -- 查询权限
     SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;
     SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;

 2. 授予权限：
     -- 授予权限
     grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;
     -- 给张三用户授予所有权限，在任意数据库任意表上
     GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;
     
 3. 撤销权限：
     -- 撤销权限：
     revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;
     REVOKE UPDATE ON db3.`account` FROM &#39;lisi&#39;@&#39;%&#39;;
</code></pre>
</li>
<li><p>权限列表</p>
<pre><code> All，ALL PRIVILEGES          所有权限
 SELECt                       查询数据
 INSERT                       插入数据
 UPDATE                       修改数据
 DELETE                       删除数据
 ALTER                        修改表
 DROP                         删除数据库/表/视图
 CREATE                       创建数据库/表 
</code></pre>
</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><blockquote>
<p>语法：select 函数(参数); </p>
</blockquote>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a><strong>字符串函数</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220606144953211.png" width="100%" / loading="lazy">


<h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a><strong>数值函数</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220606145351734.png" width="100%" / loading="lazy">

<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a><strong>日期函数</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220606171518133.png" width="100%" / loading="lazy">

<blockquote>
<p>select date_format(now(),’%Y-%m-%d’);<br>日期格式：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/func_date_format.asp">https://www.w3school.com.cn/sql/func_date_format.asp</a></p>
</blockquote>
<h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a><strong>流程函数</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220606173029853.png" width="100%" / loading="lazy">

<blockquote>
<p>注意ifnull ‘’ 时是有值的 只有null时才会显示默认值</p>
</blockquote>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h2><img src="http://hexo.xuxin.world/mysql/image-20220606173722658.png" width="100%" / loading="lazy">


<ul>
<li>外键约束<ul>
<li>删除外键<pre><code>alter table 表名 drop foreign key 外键名称;
</code></pre>
</li>
<li>添加外键<pre><code>- 建表时添加
  create table 表名(
      字段名 数据类型,
      ...
      constraint][外键名称] foreign key (外键字段名) references 主表(主表列名)
  );
- 表已存在时添加
  alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名);
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>约束行为</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220606180128967.png" width="100%" / loading="lazy"></p>
<p><strong>语法</strong></p>
<blockquote>
<p>alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名) on update/delete cascade;</p>
</blockquote>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a><strong>多表查询</strong></h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a><strong>多表关系</strong></h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a><strong>一对一</strong></h4><blockquote>
<p>将一张表拆分为多个表<br>将基本信息作为父表，其他作为子表<br>子表上添加外键，并设定为唯一约束</p>
</blockquote>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a><strong>一对多</strong></h4><blockquote>
<p>一作为父表，多作为子表<br>子表上添加外键约束</p>
</blockquote>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a><strong>多对多</strong></h4><blockquote>
<p>创建第三张表，字段有 自身id，外键字段<br>在子表上分别添加外键</p>
</blockquote>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a><strong>连接查询</strong></h3><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a><strong>内连接</strong></h4><ul>
<li>隐式内连接<pre><code>  select 字段列表 from 表1,表2 where 条件;
</code></pre>
</li>
<li>显示内连接<pre><code>  select 字段列表 from 表1 inner join 表2 on 条件;
</code></pre>
</li>
</ul>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a><strong>外连接</strong></h4><ul>
<li>左外连接<pre><code>  select 字段列表 from 表1 left outer join 表2 on 条件;
</code></pre>
</li>
<li>右外连接<pre><code>  select 字段列表 from 表1 right outer join 表2 on 条件;
</code></pre>
</li>
</ul>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a><strong>自连接</strong></h4><blockquote>
<p>注意：自连接可以是内连接也可以是外连接，区别在于，俩张表都是自己，必须起别名</p>
</blockquote>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a><strong>联合查询</strong></h3><blockquote>
<p>union/union all</p>
</blockquote>
<pre><code>    作用：将多次查询的结果联合起来(多次)
    区别：union all是直接拼接，union是去重
    语法：
            select 字段列表 from 表 where 条件
            union/union all
            select 字段列表 from 表 where 条件
    注意：多张表的列数一致，字段类型一致
</code></pre>
<h3 id="子查询-嵌套查询"><a href="#子查询-嵌套查询" class="headerlink" title="子查询(嵌套查询)"></a><strong>子查询(嵌套查询)</strong></h3><blockquote>
<ul>
<li>标量子查询</li>
<li>列子查询</li>
<li>行子查询</li>
<li>表子查询</li>
</ul>
</blockquote>
<ul>
<li>标量子查询<pre><code>  操作符号：&lt;  &gt;  &lt;&gt;  = 
  语法：
        select * from 表1 where 字段1 = (select 字段 where 条件)
注意：第二个查询语句的结果必须是单一值
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>列子查询<pre><code>  操作符号: in   not in   any  some   all
  语法：
           select * form 表 where 字段 &gt; all (select 字段 where 条件);
  注意：第二个查询语句返回值为一列数据
           all表示大于全部，所有都满足
           any和some一样，表示一个满足就行
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>行子查询<pre><code>  操作符号：in   not in   =   &lt;&gt;
  语法: 
              select * from emp where (salary,managerid) = 
              (select salary,managerid from emp where name = &#39;xx&#39;)；
  注意:  
        多行条件查询可以由
              select * from emp where (salary,managerid) =（1，2);
              等价于
              select * from emp where salary = 1 and managerid = 2;
</code></pre>
</li>
</ul>
<hr>
<ul>
<li>表子查询<ul>
<li>作为where中的条件<pre><code>  操作符号： in (表示满足这张表中的一行数据就行)
  语法：select * from where （字段1,字段2） in (select * from where 条件);
  注意：第二个查询语句的返回值是一张表
</code></pre>
</li>
<li>作为from中的表<pre><code>  语法：select * from （select * from 表1 where 条件）left join 表2 on 条件;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><pre><code>1. 事务的基本介绍
    1. 概念：
        *  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。
    2. 操作：
        1. 开启事务： start transaction/begin;
        2. 回滚：rollback;
        3. 提交：commit;
        4. 查询事务提交方式：select @@autocommit （0手动提交，1自动提交（默认，一条DML(增删改)语句会自动提交一次事务）
        5. 设置事务提交方式：set @@autocommit = 1/0
    3. 操作事务
            -关闭自动提交事务时
                    先关闭自动提交
                    set @@autocommit = 0;
                    正常时 commit
                    出错时 rollback
            -自动提交事务时
                    先开启自动提交，默认
                    set @@autocommit = 1;
                    开启事务 start transaction/begin;
                    正常时 commit
                    出错时 rollback
    4. 事务的四大特征：
      1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。
      2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
      3. 隔离性：多个事务之间。相互独立。
      4. 一致性：事务操作前后，数据总量不变
  5. 事务的隔离级别（了解）
            概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。
            存在问题：
          1. 脏读：一个事务，读取到另一个事务中没有提交的数据
          2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样（更新操作，锁行）
          3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。（增删，锁表）
          幻读说的是存不存在的问题：原来不存在的,现在存在了,则是幻读
          不可重复读说的是变没变化的问题：原来是A,现在却变为了B,则为不可重复读
            隔离级别：
          1. read uncommitted：读未提交
            * 产生的问题：脏读、不可重复读、幻读
          2. read committed：读已提交 （Oracle）
            * 产生的问题：不可重复读、幻读
          3. repeatable read：可重复读 （MySQL默认）
            * 产生的问题：幻读
          4. serializable：串行化
            * 可以解决所有的问题      
         注意：隔离级别从小到大安全性越来越高，但是效率越来越低
          数据库查询隔离级别：
            * select @@transaction_isolation;
          数据库设置隔离级别：
            * set session/global transaction isolation level  隔离级别;（read uncommitted，read committed...）
            session:会话级别，当前客户端
            global:全局，所有客户端
</code></pre>
<h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a><strong>进阶篇</strong></h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><strong>存储引擎</strong></h2><h3 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a><strong>mysql体系结构</strong></h3><img src="https://hexo.xuxin.world/mysql/image-20220607170326819.png" width="100%" / loading="lazy">

<ul>
<li>连接层<pre><code>  最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。
  服务器也会为安全接入的每个客户端验证它所具有的操作权限。
</code></pre>
</li>
<li>服务层<pre><code>  第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。
  所有跨存储引擎的功能也在这一层实现，如过程、函数等。
</code></pre>
</li>
<li>引擎层<pre><code>  存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。
  不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。
</code></pre>
</li>
<li>存储层<pre><code>  主要是将数据存储在文件系统之上，并完成与存储引擎的交互。
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>存储引擎简介</strong></p>
</blockquote>
<blockquote>
<ul>
<li>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。</li>
<li>存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</li>
</ul>
</blockquote>
<pre><code>- 查看建表语句
        show create table emp;

- 创建表时指定存储引擎
        CREATE TABLE `emp` (
        ...
        ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb3

- 显示当前数据库支持的存储引擎
        show engines;
</code></pre>
<blockquote>
<p><strong>存储引擎特点</strong></p>
</blockquote>
<ul>
<li>查看系统参数<pre><code>  show variables like &#39;innodb_file_per_table&#39;;
</code></pre>
</li>
</ul>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h3><ul>
<li>介绍<pre><code>  InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。
</code></pre>
</li>
<li>特点<pre><code>  DML操作遵循ACID模型，支持事务；
  行级锁，提高并发访问性能；
  支持外键FOREIGN KEY约束，保证数据的完整性和正确性； 
</code></pre>
</li>
<li>文件<pre><code>  XXX.ibd：x代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。
  参数：innodb_file_per_table（on/off，是否每张表对应一个表空间文件，默认on）
</code></pre>
</li>
</ul>
<img src="https://hexo.xuxin.world/mysql/image-20220607172639423.png" width="100%" / loading="lazy">


<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><strong>MyISAM</strong></h3><ul>
<li>介绍<pre><code>  MYISAM时MYSQL早起的默认存储引擎
</code></pre>
</li>
<li>特点<pre><code>  不支持事务，不支持外键
  支持表锁，不支持行锁
  访问速度快
</code></pre>
</li>
<li>文件<pre><code>    xxx.sdi:存储表结构信息
    xxx.MYD:存储数据
    xxx.MYI:存储索引
</code></pre>
</li>
</ul>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a><strong>Memory</strong></h3><ul>
<li>介绍<pre><code>  Memory引擎的表数据时存储在内存中的，由于受到硬件问题，或断电影响，只能将这些表作为临时表或缓存使用。
</code></pre>
</li>
<li>特点<pre><code>  内存存放
  hash索引（默认）
</code></pre>
</li>
<li>文件<pre><code>  xxx.sdi：存储表结构信息
</code></pre>
</li>
</ul>
<img src="http://hexo.xuxin.world/mysql/image-20220607173942982.png" width="100%" / loading="lazy">

<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a><strong>存储引擎的选择</strong></h3><pre><code>    InnoDB：如果有事务，唯一的选择，并发下一致性，除插入和查询外，有很多的更新和删除操作
    MYISAM：以读和插入为主，并且对事务完整性要求不高，如足迹，评论，但是如今被MongoDB替代
    Memory：内存存储，速度快，用于缓存，如今被redis替代
</code></pre>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a><strong>索引概述</strong></h3><blockquote>
<p>索引是帮助mysql高效获取数据的数据结构（有序)</p>
</blockquote>
<pre><code>    *优点：提高数据检索效率，降低数据库io成本
            通过索引列对数据进行排序，降低数据排序的成本，降低cpu的消耗
    *缺点：索引列需要额外的磁盘空间
              大大提高查询效率的同时增加了DML的效率，需要对索引节点额外操作
</code></pre>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a><strong>索引结构</strong></h3><p><strong>mysql中索引是在存储引擎中实现的，不同的引擎有不同的索引结构</strong></p>
<img src="http://hexo.xuxin.world/mysql/image-20220607224756131.png" width="100%" / loading="lazy">


<img src="http://hexo.xuxin.world/mysql/image-20220607225025706.png" width="100%" / loading="lazy">

<h4 id="B-tree-多路平衡查找树"><a href="#B-tree-多路平衡查找树" class="headerlink" title="B-tree:多路平衡查找树"></a><strong>B-tree:多路平衡查找树</strong></h4><pre><code>    最大度数：每个节点最大的数据存放量
</code></pre>
<img src="http://hexo.xuxin.world/mysql/image-20220607230211908.png" width="100%" / loading="lazy">


<pre><code>    可以参考网站：https://www.cs.usfca.edu/~galles/visualization/BTree.html
</code></pre>
<h4 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a><strong>B+tree</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220607230506451.png" width="100%" / loading="lazy">
        与B-tree区别：
                所有数据出现在叶子结点
                叶子结点形成一个单向链表

<h4 id="mysql中B-tree"><a href="#mysql中B-tree" class="headerlink" title="mysql中B+tree"></a><strong>mysql中B+tree</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220607230826013.png" width="100%" / loading="lazy">

<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a><strong>Hash索引</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220607231021039.png" width="100%" / loading="lazy">


<ul>
<li>Hash索引特点<pre><code>  Hash索引只能用于对等比较(=，in)，不支持范围查询(between,&gt;,&lt;,...)
  无法利用索引完成排序操作
  查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引
</code></pre>
</li>
<li>存储引擎的支持<pre><code>  在Mysql中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+tree索引在指定条件下自动构建的。
</code></pre>
</li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h4><pre><code>    为什么InnoDB存储引擎选择使用B+tree索引结构？
            相对于红黑树，单结点多数据，层级更少，搜索效率更高
            对于B-tree，无论叶子结点和非叶子结点都会保存数据，一页的大小固定16k，系统读数据到内存是以磁盘块为单位的，innodb会将多个连续磁盘块来构成一页16k，以页为基本单位读取，如果data数据很大，一页中存放的少了，树高度增加，IO次数就会增加，效率降低。
            对于hash，B+tree支持范围匹配及排序操作
</code></pre>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a><strong>索引分类</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220608000646347.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220608000758020.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220608001308148.png" width="100%" / loading="lazy">


<pre><code>    二级索引又叫辅助索引
</code></pre>
<ul>
<li>聚集索引选取规则<pre><code>  如果存在主键，主键索引就是聚集索引
  如果不存在主键，将使用第一个唯一（unique）索引作为聚集索引
  如果表没有主键，或没有合适的唯一索引，则Innodb会自动生成一个rowid作为隐藏的聚集索引
</code></pre>
</li>
<li>利用索引查询规则<pre><code>  当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>面试题</strong></p>
</blockquote>
<pre><code>    以下SQL语句中哪个效率高？
            select * from user where id = 10；
            select * from user where name = ‘Arm’；
    答：即使第二条有辅助索引，仍然需要2次索引查找，不如第一个直接查，而如果二没有辅助索引，则需要逐行扫描

    假设一行数据为1k，树高为2能存放多少数据？
    答：1页16k，能存放16行，指针占用6字节，主键int4字节，bigint8字节，算bigint，n*8+(n+1)*6 = 1024*16,n=1170,1170*16=18736

    假设一行数据为1k，树高为2能存放多少数据？
    答：1170*1170*16=21939856

    如果数据量超过了这个数字要么增加树的高度，效率降低，要么分库分表
</code></pre>
<h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a><strong>索引语法</strong></h3><ul>
<li>查看索引<pre><code>  show index from 表名;
  show index from 表名\G;  --有序
</code></pre>
</li>
<li>创建索引<pre><code>  create [unique|fulltext] index 索引名字 on 表名(字段名...);
</code></pre>
</li>
<li>删除索引<pre><code>  drop index 索引名 on 表名;
  
  注意：创建索引时，唯一则指定unique，多字段联合索引需要多字段，常规索引正常，主键索引建表时存在
</code></pre>
</li>
</ul>
<h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a><strong>SQL性能分析</strong></h3><h4 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a><strong>查看执行频次</strong></h4><ul>
<li>查看执行频次（select,insert,delete,update）<pre><code>  shwo global｜session status like ‘Com_______’；
  注意：global是全局，session是当前会话，七个_
</code></pre>
</li>
</ul>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a><strong>慢查询日志</strong></h4><blockquote>
<p><strong>满查询日志记录了所有执行时间超过指定参数（long_query_time,单位：秒，默认10）的所有sql语句的日志。mysql的慢查询日志默认没有开启，需要改配置文件（/etc/my.cnf）中配置一下信息</strong></p>
</blockquote>
<pre><code>    #开启mysql慢日志查询的开关
    slow_query_log=1
    #设置慢日志的时间为2秒，sql语句执行时间超过2秒，就会记录在慢日志里
    long_query_time=2
</code></pre>
<blockquote>
<p><strong>配置完毕后，重启mysql：systemctl restart mysqld.service</strong><br><strong>查看慢日志：/var/lib/mysql/localhost-slow.log</strong></p>
</blockquote>
<ul>
<li>查看是否开启慢日志<pre><code>  Show variables like &#39;slow_query%&#39;;
</code></pre>
</li>
<li>查看慢日志<pre><code>  cat /var/lib/mysql/localhost-slow.log 
  注意：这里的文件名是不确定的，需要第一步命令查看慢文件存放位置：slow_query_log_file的值
</code></pre>
</li>
</ul>
<h4 id="mysql启动报错怎么办？"><a href="#mysql启动报错怎么办？" class="headerlink" title="mysql启动报错怎么办？"></a><strong>mysql启动报错怎么办？</strong></h4><blockquote>
<p>mysql启动报错怎么办？</p>
</blockquote>
<pre><code>    错误如下：Job for mysqld.service failed because the control process exited with error code. See &quot;systemctl status mysqld.service&quot; and &quot;journalctl -xe&quot; for details.

    答：启动不成功无非就是启动命令、服务器资源环境、my.cnf的配置文件问题。
    查看mysql日志文件：cat /var/log/mysql.log｜grep ERROR
    基本上都是配置文件的参数打错字了
</code></pre>
<h4 id="查询profile"><a href="#查询profile" class="headerlink" title="查询profile"></a><strong>查询profile</strong></h4><blockquote>
<p>慢查询只能查到大于预设值的语句，并且不能查看每条语句的耗时情况</p>
</blockquote>
<ul>
<li>查询mysql是否支持profile查询<pre><code>  select @@have_profiling
</code></pre>
</li>
<li>查询profile是否开启<pre><code>  select @@profiling
</code></pre>
</li>
<li>开启profile<pre><code>  set global/session profiling=1;
</code></pre>
</li>
<li>查看profile<pre><code>  show profiles;
</code></pre>
</li>
<li>查看profile指定语句<pre><code>  show profile for query 查询id;
</code></pre>
</li>
<li>查看profile指定语句附带cpu使用情况<pre><code>  show profile cpu for query 查询id;
</code></pre>
</li>
</ul>
<h4 id="查看explain执行计划"><a href="#查看explain执行计划" class="headerlink" title="查看explain执行计划"></a><strong>查看explain执行计划</strong></h4><blockquote>
<p><strong>可以查看是否用到索引，表的连接情况等信息</strong></p>
</blockquote>
<ul>
<li>查看explain执行计划<pre><code>  explain/desc 查询语句
</code></pre>
</li>
<li>各字段含义：<pre><code>  id：操作表的顺序（id相同，从上往下依次，id不同，值越大，越先执行）
  select_type:表示select的类型，常见的有simple（简单表，不使用表连接或者子查询），primary（主查询，外层的查询），union（联合查询的第二个或者后面的查询），subquery（select/where之后包含了子查询）
  type：性能由好到差为：null，system，const，eq_ref,ref,range,index,all。system为查询系统变量，const为查询主键或唯一索引，ref：用了辅助索引，index：用了索引但对索引全表扫描，all：全表扫描
  possiable_key:可能用到的索引
  key：实际用到的索引，为null则没有用到索引
  key_len：索引使用的字节数，越小越好，和值有关系
  rows：必须查询的行数
  filtered：返回结果占需要读取的行数的百分比，100为最好
  Extre：额外信息
</code></pre>
</li>
</ul>
<h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a><strong>索引使用</strong></h3><ul>
<li>最左法则<pre><code>  联合查询中，索引最左边的必须存在，并且不能跳过中间某一列，否则后面的索引列失效
</code></pre>
</li>
<li>范围查询<pre><code>  联合查询中，不能出现（&gt;,&lt;）可以使用&lt;=,&gt;=，否则后面的索引失效
</code></pre>
</li>
<li>索引列运算<pre><code>  不要在索引列上运算，比如字符串操作函数，否则索引失效
</code></pre>
</li>
<li>字符串不加引号<pre><code>  字符串类型列查询不加引号导致索引失效
</code></pre>
</li>
<li>模糊匹配<pre><code>  模糊查询后面模糊不失效，前面模糊失效
</code></pre>
</li>
<li>or连接的条件<pre><code>  or连接的条件，如果俩边都有索引，则有效，只要一边没有则失效，可以对没有索引的创建索引
</code></pre>
</li>
<li>数据分布影响<pre><code>  如果mysql评估全表扫描比索引还快，不会走索引，会全表扫描
</code></pre>
</li>
<li>SQL提示<pre><code>  SQL提示是优化数据库的重要手段，在sql语句中插入一些人为你的提示来优化，比如有多个索引，可以指定使用哪个索引
  use index ：建议数据库使用，但数据库评估后如果不满意，可能不会采纳        
  ignore index:直接忽略
  force index：强制使用
  select * from 表名 use/ignore/force index(索引名) where 条件;
</code></pre>
</li>
<li>覆盖索引<pre><code>  当select 列中所有返回的列都能在索引中找到，最优，如果找不到需要回表查找聚集索引，性能相对低一点，所以尽量避免select *，对语句优化，需要同时照顾select查询的列
</code></pre>
</li>
<li>前缀索引<pre><code>  如果一个字段内容比较大，可以根据前缀创建前缀索引
      create index 索引名字 on 表名(列名(前缀个数));

  前缀个数取值问题：
      - 当索引选择性越高越好，如唯一索引选择性为1，可以通过
          select count(distinct substring(字段,1,前缀个数))/count(*) from 表 where 条件
      - 前缀个数越少越好，选择性越高越好，综合选取
</code></pre>
</li>
<li>单列索引和联合索引<pre><code>  如果条件是多个字段，推荐使用联合索引，因为不需要回表查询
</code></pre>
</li>
</ul>
<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a><strong>索引设计原则</strong></h3><pre><code>    1. 针对于数据量较大，且查询比较频繁的表建立索引。
    2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
    3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
    4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
    5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
    6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
    7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。否则导致引擎放弃使用索引而进行全表扫描，非要使用null，可以在null上设置默认值0，确保表中num列没有null值
    8. 尽量使用数字类型字段，若只含数值信息的字段，尽量不要设计为字符型，这样会降低查询和连接的性能，并会增加存储开销，这是因为引擎在处理查询和连接时，会逐个比较字符串中每一个字符。而对于数字型而言，只需要对比一次就可以了。
    9. 对于子查询慎用 in，可以将子查询当成一张表连接查询，覆盖索引+连接查询
</code></pre>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><strong>SQL优化</strong></h2><h3 id="插入优化"><a href="#插入优化" class="headerlink" title="插入优化"></a><strong>插入优化</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--1.批量插入</span><br><span class="line">		一个个插入，每次都要与数据库连接，网络数据传输</span><br><span class="line">		如果一次性插入的数据量过大，也不建议一条语句一次性全部插入，一条语句500-1000合适</span><br><span class="line">		insert into 表名 values(值1，值2),(...),(...);</span><br><span class="line">--2.手动开启事务</span><br><span class="line">		插入语句结束后自动提交事务，每条语句都会，太频繁影响性能</span><br><span class="line">		begin/start transaction;</span><br><span class="line">		insert into 表名 values(值1，值2),(...),(...);</span><br><span class="line">		insert into 表名 values(值1，值2),(...),(...);</span><br><span class="line">		...</span><br><span class="line">		commit;</span><br><span class="line">--3.主键顺序插入</span><br><span class="line">		主键顺序插入要优于乱序插入,基于数据组织结构的</span><br></pre></td></tr></table></figure>

<p><strong>大批量数据插入</strong></p>
<blockquote>
<p>如果大批量数据要插入insert插入效率极低，耗时极长，可以使用mysql提供的load指令</p>
</blockquote>
<ol>
<li>连接mysql客户端时需要携带参数–local—infile<pre><code> mysql --local-infile -u 用户名 -p 密码
</code></pre>
</li>
<li>设置全局参数，开启本地加载文件导入表的开关<pre><code> set global local_infile = 1；
</code></pre>
</li>
<li>执行load指令<pre><code> load data local infile ‘路径’ into table 表名 fields terminated by ‘,’ lines terminated by &#39;\n&#39;;
</code></pre>
</li>
</ol>
<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a><strong>主键优化</strong></h3><h4 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a><strong>页分裂</strong></h4><blockquote>
<ul>
<li><strong>在innodb存储引擎中，数据是按主键顺序存储的</strong>，<strong>一页存放多条数据，页之间双向指针维护</strong></li>
<li><strong>乱序插入时，如果某一页的位置满了，插不进去，会放到另一页中，把那页的一半也放进去，重新维护双向指针</strong></li>
</ul>
</blockquote>
<img src="http://hexo.xuxin.world/mysql/image-20220609181121685.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220609181148669.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220609181210985.png" width="100%" / loading="lazy">



<h4 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a><strong>页合并</strong></h4><blockquote>
<ul>
<li><strong>删除数据时，不是正真删除，而是设置标记，允许其他数据使用，当标记数达到一页中的某个阈值（MERGE_THRESHOLD）会进行页合并操作，判断左右有没有一半的空间，合成一页</strong></li>
<li><strong>MERGE_THRESHOLD：合并页阈值，默认是50%，可以自己设置，在创建表或者创建索引时指定。</strong></li>
</ul>
</blockquote>
<h4 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a><strong>主键设计原则</strong></h4><pre><code>    1. 满足业务需求的情况下，尽量降低主键的长度。
    2. 插入数据时，尽量选择顺序插入，选择使用AUTO INCREMENT自增主键。
    3. 尽量不要使用UUID做主键或者是其他自然主键，如身份证号公
    4. 业务操作时，避免对主键的修改。
</code></pre>
<h3 id="orderby优化"><a href="#orderby优化" class="headerlink" title="orderby优化"></a><strong>orderby优化</strong></h3><blockquote>
<ul>
<li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。、</li>
</ul>
<p><strong>注意</strong>：当orderby的多字段同时升序或降序走索引，不同走缓冲区，但是如果没有索引或者只有一个，不好意思，回表扫描，得到完整数据再放过缓冲区</p>
</blockquote>
<blockquote>
<p>优化原则<br>        1. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。<br>        2. 尽量使用覆盖索引。<br>        3. 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。<br>                create index 索引名 on 表名(列 desc,列 asc);<br>        4. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort buffer_size（默认256k）因为如果超过了这个值，会在磁盘文件中排序，效率低</p>
</blockquote>
<h3 id="groupby优化"><a href="#groupby优化" class="headerlink" title="groupby优化"></a><strong>groupby优化</strong></h3><pre><code>    1. 在分组操作时，可以通过索引来提高效率
    2. 分组操作时，索引的使用也是满足最左前缀法则的。
</code></pre>
<h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a><strong>limit优化</strong></h3><blockquote>
<ul>
<li>在大数据量下分页查询，limit 2000000，10中第一个参数越大，耗时越长。此时查询需要2000010行，但返回只有10行，2000000行被丢弃了</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>优化思路：一般分页查询时，通过创建 覆盖索引 能够提高性能，可以通过覆盖索引加子查询形式进行优化</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在in的子查询中不能有limit，可以把子查询的语句当成一张表来多表查询</li>
</ul>
</blockquote>
<h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a><strong>count优化</strong></h3><blockquote>
<p><strong>MYISAM引擎维护一个表的总行数，对于没有条件的count（*），效率很高</strong><br><strong>Innodb则需要一行行数据取出来计数</strong><br><strong>优化思路</strong></p>
</blockquote>
<img src="http://hexo.xuxin.world/mysql/image-20220609191955401.png" width="100%" / loading="lazy">


<h3 id="Update优化"><a href="#Update优化" class="headerlink" title="Update优化"></a><strong>Update优化</strong></h3><blockquote>
<p><strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</strong></p>
</blockquote>
<h3 id="多表查询优化"><a href="#多表查询优化" class="headerlink" title="多表查询优化"></a><strong>多表查询优化</strong></h3><pre><code>    1. from和join，选择join
    2. left join的驱动表是左边，小表驱动大表，不过mysql优化器有优化，自动将结果集小的当驱动表
    3. 反范式设计，范式是减少数据冗余节省磁盘的，以空间换时间
    4. 创建外键索引，如果中间表多个字段用到条件上，可以把多个外键建立联合索引
</code></pre>
<h2 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a><strong>存储对象</strong></h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a><strong>视图</strong></h3><ul>
<li><p>视图介绍    </p>
<pre><code>  视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。
  通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。
</code></pre>
</li>
<li><p>基本使用</p>
<pre><code>  1. 创建视图
          create or replace view view_dept as select * from dept where id &lt; 10 ;
  2. 修改试图
          create or replace view view_dept as select  id from dept where id&lt;10;
          alter view view_dept as select id from dept where id&lt;10;
  3. 删除试图
          drop view if exists view_dept;
</code></pre>
</li>
<li><p>视图检查选项</p>
<pre><code>  当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。
  MySQL允许基于另一个视图创建视图，它还会检查依赖视 图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：（此外视图增删改会在基表上记录）
      CASCADED（默认）
      LOCAL 
  语法：create or replace view view_dept as select * from dept where id &lt; 10 with check option;
  - with cascaded check option
          集联检查，会检查当前视图包括所依赖的所有视图（即使依赖的视图没有检查选项），也是默认方式。
  - with local check option
          会检查当前包括递归检查依赖的视图，但如果依赖的没有检查选项则不检查
</code></pre>
</li>
<li><p>视图的更新</p>
<pre><code>  注意：要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：
  1. 聚合函数或窗口函数（SUM（）、MIN（）、MAX（）、COUNT等）
  2. DISTINCT
  3. GROUP BY
  4. HAVING
  5. UNION或者UNION ALL
</code></pre>
</li>
<li><p>视图的作用</p>
<pre><code>  1. 简单
      经常使用的查询可以被定义为视图，不必为以后的操作每次指定全部的条件。
  2. 安全
      数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据
  3. 数据独立
      视图可帮助用户屏蔽真实表结构变化带来的影响。如：基表字段换名字了，视图只需要其别名就行
</code></pre>
</li>
</ul>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><strong>存储过程</strong></h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h4><ul>
<li>介绍<pre><code>  存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作
  减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。
  存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。
</code></pre>
</li>
<li>特点<pre><code>  封装，复用
  可以接收参数，也可以返回数据
  减少网络交互，效率提升
</code></pre>
</li>
<li>语法<pre><code>  1. 创建：
          create procedure p1()
          begin
          select * from dept where id &lt;= 10;
          end;
      注意：在命令行中创建时需要指定结束符，使用delimiter指定，delimiter $$
  2. 调用：
          call p1();
  3. 查看
          select * from information_schema.ROUTINES where ROUTINE_SCHEMA = &#39;test&#39;;
          show create procedure p1;
  4. 删除    
          drop procedure if exists p1;              
</code></pre>
</li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h4><ol>
<li>系统变量<pre><code> --介绍：系统变量是mysql服务器提供的，属于服务器层面，分为全局变量(global)和会话变量(session)
 --查看系统变量
     show global variables;
     show global variables like &#39;have_profiling&#39;;
     select @@have_profiling;
 --设置系统变量
     set session autocommit = 0;
     set @@autocommit = 1; 
注意：如果没有指定session/global，默认是session，会话级别
     mysql服务重启之后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cnf中配置
</code></pre>
</li>
<li>用户自定义变量<pre><code>     --介绍：用户自定义变量不需要提前声明，用的时候直接用@变量名，作用域为当前连接
     --赋值
     1. set @myname = &#39;徐鑫&#39;;
     2. set @myage := 18;
     3. set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;
     4. select @mycolor := &#39;red&#39;;
     5. select count(*) into @mycount from dept;
         --使用
                 select @myname, @myage, @mygender, @myhobby, @mycolor, @mycount;
       注意：用户自定义的变量无需声明，对于没有赋值的，取到的是null而不会报错
</code></pre>
</li>
<li>局部变量<pre><code> --介绍：局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量
 --声明
     declare 变量名 变量类型 [default 值];
     变量类型就是数据库字段类型：int，bigint，char，varchar，date，time等
 --赋值
     set 变量名=值;
     set 变量名:=值;
     select 字段 into 变量名 from 表名;
 --实例
     create procedure p2()
     begin
         declare a int;
         select count(*) into a from dept;
         select a;
     end;
</code></pre>
</li>
</ol>
<h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h4><ul>
<li><p>if</p>
<pre><code>  语法：

  if 条件 then
  ...
  elseif 条件 then
  ...
  else
  ...
  end if;
</code></pre>
</li>
<li><p>参数</p>
<pre><code>  in：输入参数
  out：输出参数，需要拿用户自定义变量接收
  inout：既是输入又是输出，需要传用户自定义变量并且赋值           
  实例：
      create procedure p4(in score int ,out result varchar(10))
      begin
      if score &gt;= 85 then
              set result = &#39;优秀&#39;;
      elseif score &gt;= 60 then
              set result = &#39;及格&#39;;
      else
              set result = &#39;不及格&#39;;
      end if;
      select result;
      end;
      
      set @score := 32;
      call p4(@score,@result);
      select @result;
</code></pre>
</li>
<li><p>case</p>
<pre><code>     第一种：
         case 变量
         when 值 then ...
         when 值 then ...
         else ...
         end case;
     第二种：
         case 
         when 条件 then ...
         when 条件 then ...
         else ...
         end case;
     实例：
      create procedure p5(in a int)
      begin
          declare result varchar(10);
          case
              when a &lt;= 3 and a &gt;= 1 then
                  set result := &#39;第一季度&#39;;
              when a &lt;= 6 and a &gt;= 4 then
                  set result := &#39;第二季度&#39;;
              when a &lt;= 9 and a &gt;= 7 then
                  set result := &#39;第三季度&#39;;
              when a &lt;= 12 and a &gt;= 10 then
                  set result := &#39;第四季度&#39;;
          end case;
          select concat(&#39;你输入的月份为&#39;,a,&#39;，结果为&#39;,result);
      end;
      call p5(4);
</code></pre>
</li>
<li><p>while</p>
<pre><code>  语法：
          while 条件 do ...
          end while;
  实例：
        create procedure p6(in n int)
        begin
            declare tmp int default 1;
            declare result int default 0;
            while tmp&lt;=n do
                set result = result+tmp;
                set tmp = tmp+1;
            end while;
            select result;
        end;
        call p6(3);
</code></pre>
</li>
<li><p>repeat</p>
<pre><code>   介绍：有条件循环，先执行一次，再看条件，直到满足则退出
   语法：
           repeat ... 
           until 条件
           end repeat;
   实例：
           create procedure p7(in a int)
          begin
              declare result int default 0;
              declare tmp int default a;
              repeat
                  set result := result + tmp;
                  set tmp := tmp - 1;
              until tmp = 0
              end repeat;
              select result;
          end;
          call p7(2);
</code></pre>
</li>
<li><p>loop</p>
<pre><code>  介绍：死循环，利用leave和iterate来控制流程
  leave 标志:退出循环
  iterate 标志：跳到下一条循环
  实例： 偶数累加
      create procedure p8(in a int)
      begin
          declare result int default 0;
          declare tmp int default a;
          sum:loop
              if tmp = 0 then
                  leave sum;
              elseif tmp%2=1 then
                  set tmp := tmp - 1;
                  iterate sum;
              else
                  set result := result + tmp;
                  set tmp := tmp - 1;
              end if;
          end loop sum;
          select result;
      end;
      call p8(6);
</code></pre>
</li>
</ul>
<h4 id="游标与条件处理程序"><a href="#游标与条件处理程序" class="headerlink" title="游标与条件处理程序"></a><strong>游标与条件处理程序</strong></h4><ul>
<li><p>游标与条件处理程序</p>
<pre><code>    --介绍
          游标 (CURSOR) :是用来存储查询结果集的数据类型，在存储过程和西数中可以使用游标对结果集进行循环的处理。
          条件处理程序可以用来在流程控制结构执行过程中遇到问题时相应的处理步骤
    --语法
              声明游标：declare yb_name_job cursor for 查询语句;
              打开游标：open yb_name_job;
              获取游标记录：fetch yb_name_job into tmp_name,tmp_job;
              关闭游标：close yb_name_job;
              声明条件处理程序：declare handler_action handler for condition_value 退出后执行语句;

              handler_action:
                      continue:继续执行当前程序
                      exit：终止执行当前程序
              condition_value
                      sqlstate sqlstate_value:状态码
                      sqlwarning：所有01开头的状态码
                      not found：所有02开头的状态码
                      sqlexception：所有其他的
    --实例
              create procedure p1(in age int)
            begin
                  declare tmp_name varchar(10);
                  declare tmp_job varchar(10);
                  declare yb_name_job cursor for select name,job from emp where age&lt;=emp.age;
                  declare exit handler for not found close yb_name_job;
                  open yb_name_job;
                  drop table if exists tmp_name_job;
                  create table if not exists tmp_name_job(
                      id int auto_increment primary key ,
                      name varchar(10),
                      job varchar(10)
                  );
                  while true do
                      fetch yb_name_job into tmp_name,tmp_job;
                      insert into tmp_name_job values(null,tmp_name,tmp_job);
                  end while;
                  close yb_name_job;
                  select * from tmp_name_job;
          end;
          call p1(40);
</code></pre>
</li>
</ul>
<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a><strong>存储函数</strong></h3><blockquote>
<p><strong>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下</strong></p>
</blockquote>
<ul>
<li><p>语法</p>
<pre><code>  create function 函数名(参数)
  returns 类型 deterministic/no sql/reads sql data
  begin
          ...
      return 返回值;
  end;

  注意：
          deterministic：输入相同，输出相同
          no sql：没有sql语句
          reads sql data：只有读sql，没有写sql
          参数可以不写in
</code></pre>
</li>
<li><p>实例</p>
<pre><code>  create function f1(a int)
  returns int deterministic
  begin
      declare result int default 0;
      declare tmp int default a;
      while tmp&gt;=0 do
          set result:=result+tmp;
          set tmp:=tmp-1;
      end while;
      return result;
  end;
  select f1(21);
</code></pre>
</li>
</ul>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h3><ul>
<li>介绍<pre><code>  触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特
  性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。
  使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句
  级触发。
</code></pre>
</li>
<li>语法<pre><code>  1. 创建触发器
          create trigger 触发器名字
          before/after insert/update/delete
          on 表名 for each row --行级触发器
          begin
          ...
          end;
  2. 查看触发器
          show trigger； --默认查看当前数据库的触发器
  3. 删除触发器
          drop trigger [数据库名字]触发器名字; --不指定数据库的名字，则默认当前数据库
</code></pre>
</li>
</ul>
<img src="http://hexo.xuxin.world/mysql/image-20220611230435016.png" width="100%" / loading="lazy">

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a><strong>锁</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><ul>
<li>介绍<pre><code>  锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、 1/0）的争用以外，数据也是
  一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访
  问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。
</code></pre>
</li>
<li>分类<pre><code>  MysQL中的锁，按照锁的粒度分，分为以下三类：
      1. 全局锁：锁定数据库中的所有表。
      2. 表级锁：每次操作锁住整张表。
      3. 行级锁：每次操作锁住对应的行数据。
</code></pre>
</li>
</ul>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a><strong>全局锁</strong></h3><ul>
<li>介绍<pre><code>  全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。
  其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。
</code></pre>
</li>
<li>演示————数据库备份<pre><code>  加锁：flush tables with read lock;
  备份：mysqldump -h43.142.107.197 -uroot -p1234 test &gt; /Users/xuxin/Downloads/test.sql
  解锁：unlock tables;
  注意：数据库中加全局锁，是一个比较重的操作，存在以下问题：
      1. 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
      2. 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志 (binlog），会导致主从延迟。
  在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。
  语法：mysqldump --single-transaction -h43.142.107.197 -uroot -p1234 test &gt; /Users/xuxin/Downloads/test.sql
</code></pre>
</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a><strong>表级锁</strong></h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a><strong>表锁</strong></h4><ul>
<li>介绍<pre><code>  表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。
</code></pre>
</li>
<li>分类<pre><code>  - 表共享读锁
  - 表独占写锁
</code></pre>
</li>
<li>语法<pre><code>  加锁：lock tables 表名... read/write
  释放锁：unlock tables / 客户端断开连接。
</code></pre>
</li>
<li>特性<pre><code>  读锁：各个客户端可以读，都不可以写
  写锁：自己可以读写，其他都不可以
</code></pre>
</li>
</ul>
<img src="http://hexo.xuxin.world/mysql/image-20220613021834174.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220613021847582.png" width="100%" / loading="lazy">

<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a><strong>元数据锁</strong></h4><ul>
<li>介绍<pre><code>  元数据锁（meta data lock，MDL），MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。
  
</code></pre>
</li>
<li>分类<pre><code>  元数据读锁(共享)：增删改等语句，自动添加
  元数据写锁(排它)：修改表结构
  
</code></pre>
</li>
<li>查看元数据锁<pre><code>  select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;
</code></pre>
</li>
</ul>
<img src="http://hexo.xuxin.world/mysql/image-20220613023057649.png" width="100%" / loading="lazy">

<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a><strong>意向锁</strong></h4><ul>
<li>介绍<pre><code>  为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁,使得表锁不用检查每行数据是否加锁
</code></pre>
</li>
<li>分类<pre><code>  1. 意向共享锁（IS）：由语句 select.... lock in share mode添加。
  2. 意向排他锁（IX）：由insert、update、 delete、 select.. for update 添加。
</code></pre>
</li>
<li>兼容性<pre><code>  1. 意向共享锁（IS）：与表锁共享锁(read）兼容，与表锁排它锁（write）互斥。
  2. 意向排他锁（IX）：与表锁共享锁（read)及排它锁（write）都互斥。意向锁之间不会互斥。
</code></pre>
</li>
<li>查看意向锁<pre><code>  select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from   performance_schema.data_locks;
</code></pre>
</li>
</ul>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a><strong>行级锁</strong></h3><ul>
<li>介绍<pre><code>  行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。
</code></pre>
</li>
<li>分类<pre><code>  InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：
  1. 行锁 (Record Lock)：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
  2. 间隙锁 (Gap Lock)：锁定索引记录问隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
  3. 临键锁(Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，井锁住数据前面的间隙Gap。在RR隔离级别下支持。
</code></pre>
</li>
</ul>
<h4 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a><strong>记录锁</strong></h4><ul>
<li><p>分类</p>
<pre><code>  1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
  2. 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。
</code></pre>
</li>
<li><p>注意</p>
<pre><code>  默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。

  1. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
  2. InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。
</code></pre>
</li>
<li><p>查看行锁</p>
<pre><code>  select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from   performance_schema.data_locks;
</code></pre>
</li>
</ul>
<img src="http://hexo.xuxin.world/mysql/image-20220613025941308.png" width="100%" / loading="lazy">

<img src="http://hexo.xuxin.world/mysql/image-20220613030048567.png" width="100%" / loading="lazy">


<h4 id="间隙锁-临间锁"><a href="#间隙锁-临间锁" class="headerlink" title="间隙锁/临间锁"></a><strong>间隙锁/临间锁</strong></h4><pre><code>    默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引|(扫描，以防止幻读。
        1. 索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁。
        2. 索引上的等值查询(普通索引)，next-key lock退化为间隙锁，锁自己值和左右间隙
        3. 索引上的范围查询(唯一索引)，其范围内的，到第一个不满足的值间隙，自己的值都会加锁
    注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。
</code></pre>
<h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a><strong>InnoDB引擎</strong></h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a><strong>逻辑存储结构</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220613222348015.png" width="100%" / loading="lazy">


<ul>
<li>表空间（ibd文件）：<pre><code>  一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。
</code></pre>
</li>
<li>段：<pre><code>  分为数据段 (Leaf node segment)、索引段(Non-leaf node segment）、回滚段（Rollback segment),
  InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。
</code></pre>
</li>
<li>区：<pre><code>  表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。
</code></pre>
</li>
<li>页：<pre><code>  是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请4-5个区。    
</code></pre>
</li>
<li>行：<pre><code>  InnoDB 存储引擎数据是按行进行存放的。
  Txid：每次对某条记泉进行改动时，都会把对应的事务id威值给trx_id隐藏列。
  RollL_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。
</code></pre>
</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220614010615268.png" width="100%" / loading="lazy">

<h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a><strong>内存架构</strong></h4><blockquote>
<ul>
<li>Buffer Pool：缓存常规操作数据</li>
<li>Change Buffer：减少非唯一二级索引随机带来的i/o</li>
<li>Log Buffer：日志缓存</li>
<li>Adaptive Hash Index：自适应哈希索引，提高查询效率</li>
</ul>
</blockquote>
<ul>
<li><p>Buffer Pool</p>
<pre><code>  缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，
  先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，
  从而减少磁盘i/o，加快处理速度。缓冲池以Page页为单位，底层采用链表数据结构管理Page。

  根据状态，将Page分为三种类型：
          free page：空闲page，未被使用。
          clean page：被使用page，数据没有被修改过。
          dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。
</code></pre>
</li>
<li><p>Change Buffer：</p>
<pre><code>  更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中,不会直接操作磁盘，
  而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。

  Change Buffer的意义是什么？
      与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。
      同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘i/o。
      有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘i/o。
</code></pre>
</li>
<li><p>Adaptive Hash Index</p>
<pre><code>  自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。
  自适应哈希索引，无需人工干预，是系统根据情况自动完成。
  参数：adaptive_hash_index，可以查看mysql是否开启
</code></pre>
</li>
<li><p>Log Buffer：</p>
<pre><code>  日志缓冲区，用来保存要写入到磁盘中的log日志数据 （rede log、 undo log)，默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘i/o。
  参数：
      innodb_ log _buffer_size：缓冲区大小
      innodb_flush_log_at_trx_commit：日志刷新到磁盘时机
  日志刷新到磁盘时机
      1:日志在每次事务提交时写入并刷新到磁盘，默认
      0:每秒将日志写入并刷新到磁盘一次。
      2:日志在每次事务提交后写入，井每秒刷新到磁盘一次。
</code></pre>
</li>
</ul>
<h4 id="磁盘架构"><a href="#磁盘架构" class="headerlink" title="磁盘架构"></a><strong>磁盘架构</strong></h4><ul>
<li>System Tablespace：<pre><code>  系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。
  （在MySQL5.x版本中还包含InnoDB数据字典、undolog等）
  参数：innodb_data_ file_path
</code></pre>
</li>
<li>File-Per-Table Tablespaces：<pre><code>  每个表的文件表空间包含单个InnoDB表的数据和素引，并存储在文件系统上的单个数据文件中。
  参数：innodb_file_per_table
</code></pre>
</li>
<li>General Tablespaces：<pre><code>  通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。
</code></pre>
</li>
<li>Undo Tablespaces<pre><code>  撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。
</code></pre>
</li>
<li>Temporary Tablespaces： <pre><code>  InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。
</code></pre>
</li>
<li>Doublewrite Buffer Files<pre><code>  双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。
</code></pre>
</li>
<li>Redo Log：<pre><code>  重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲(redo log buffer）以及重做日志文件 (redo log）,
  前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时,发生错误时，进行数据恢复使用。
  以循环方式写入重做日志文件，法及两个文件：
      ib logfileo
      ib logfile1
</code></pre>
</li>
</ul>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a><strong>后台线程</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220614010919117.png" width="100%" / loading="lazy">

<h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a><strong>事务原理</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220614011234113.png" width="100%" / loading="lazy">

<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a><strong>redo log</strong></h4><pre><code>    分为俩块：**重做日志缓冲区**和**重做日志文件**

    内容：物理日志，记录数据内容

    作用：当发生极端情况时，内存的中的数据来不及刷新到磁盘，redolog可以重新执行

    原理：先写日志（WAL）

    注意：重做日志文件有2个文件，每次都是循环追加，定时清理
</code></pre>
<img src="http://hexo.xuxin.world/mysql/image-20220620164103763.png" width="100%" / loading="lazy">

<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a><strong>undo log</strong></h4><pre><code>    - 作用：回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和 MVCC(多版本并发控制)

    - 内容：undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，
    反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的內容并进行回滚。

    - Undo log销段：undo log在事务执行时产生，事务提交时，并不会立即州除undo log，因为这些日志可能还用于MVCC。

    - Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。
</code></pre>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h3><pre><code>    - 当前读
            读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：
            select... lock in share mode(共享锁)，select.. for update、 update、insert、 delete(排他锁)都是一种当前读。
    - 快照读
            简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。
            Read Committed：每次select，都生成一个快照读。
            Repeatable Read：开启事务后第一个select语句才是快照读的地方。
            Serializable：快照读会退化为当前读。
    - MVCC
            全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现，MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。
</code></pre>
<h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a><strong>隐式字段</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220620170315495.png" width="100%" / loading="lazy">

<blockquote>
<p><strong>查看idb文件</strong>:ibd2sdi 文件名</p>
</blockquote>
<h4 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo log"></a><strong>undo log</strong></h4><pre><code>    回滚日志，在insert、 update、 delete的时候产生的便于数据回滚的日志。
    当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。
    而update、 delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。
</code></pre>
<img src="http://hexo.xuxin.world/mysql/image-20220620170930571.png" width="100%" / loading="lazy">

<h4 id="readview"><a href="#readview" class="headerlink" title="readview"></a><strong>readview</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220620171105766.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220620171422232.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220620171438199.png" width="100%" / loading="lazy">

<h3 id="事务原理总结"><a href="#事务原理总结" class="headerlink" title="事务原理总结"></a><strong>事务原理总结</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220620172159103.png" width="100%" / loading="lazy">


<ul>
<li>一致性：<pre><code>  undolog负责失败回滚，redo log负责极端情况下任务重做
</code></pre>
</li>
<li>隔离性：<pre><code>  读已提交：隐藏字段记录事物id，readview根据事物id找出已提交的版本，在undolog版本链中找到版本，读出已提交版本
  可重复读：rc中每次快照读都生成readview，rr中则只有第一次读生成，后续复用
  串行化：每个读的数据行上加上共享锁（除此之外，消除幻读可以利用间隙锁锁住区域避免其他事物的操作）
</code></pre>
</li>
<li>原子性：<pre><code>  undo log事物回滚
</code></pre>
</li>
<li>持久性：<pre><code>  redo log在刷新失败下的任务重做
</code></pre>
</li>
</ul>

<div class="markmap-container" style="height:700px">
  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;&lt;em&gt;原子性&lt;/em&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3],&quot;f&quot;:true},&quot;v&quot;:&quot;解释：事务是最小操作单元，同时成功，同时失败&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4],&quot;f&quot;:true},&quot;v&quot;:&quot;如何保证：undo log（回滚日志）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;一致性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7],&quot;f&quot;:true},&quot;v&quot;:&quot;解释：事务操作前后，数据总量一致&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8],&quot;f&quot;:true},&quot;v&quot;:&quot;如何实现：redo log 和 undo log&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9],&quot;f&quot;:true},&quot;v&quot;:&quot;redo log：保证了 异常情况下数据同步&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10],&quot;f&quot;:true},&quot;v&quot;:&quot;undo log：保证了回滚数据同步&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;隔离性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13],&quot;f&quot;:true},&quot;v&quot;:&quot;解释：数据库提供隔离机制，来保证事物独立环境运行&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14],&quot;f&quot;:true},&quot;v&quot;:&quot;如何实现：锁+MVCC&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15],&quot;f&quot;:true},&quot;v&quot;:&quot;隔离问题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[15,16],&quot;f&quot;:true},&quot;v&quot;:&quot;脏读：读一个没有提交的数据&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17],&quot;f&quot;:true},&quot;v&quot;:&quot;不可重复读：2次读中间，别人修改提交了，导致第二次读的不一样&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18],&quot;f&quot;:true},&quot;v&quot;:&quot;幻读：2次读的时候，别人插入了新的记录提交了，由于可重复读了，第二次读的一样，导致第一次没有数据，想插入，结果插入失败，第二次读还是没有，好像有幻觉了&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19],&quot;f&quot;:true},&quot;v&quot;:&quot;隔离级别&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20],&quot;f&quot;:true},&quot;v&quot;:&quot;read uncommitted：读未提交————当前读，但不加锁，因为是当前读所以不受MVCC控制&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21],&quot;f&quot;:true},&quot;v&quot;:&quot;read committed：读已提交 （Oracle默认）————每次读都是快照读，MVCC控制读一定是已经提交了的&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[21,22],&quot;f&quot;:true},&quot;v&quot;:&quot;repeatable read：可重复读 （MySQL默认）—————只有第一次快照读，MVCC控制，后续的直接沿用快照&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23],&quot;f&quot;:true},&quot;v&quot;:&quot;serializable：串行化————每次读都是当前读，加锁&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;持久性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[24,25],&quot;f&quot;:true},&quot;v&quot;:&quot;解释：事务提交或回滚后，数据库数据的更改是永久的&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[25,26],&quot;f&quot;:true},&quot;v&quot;:&quot;如何保证：redo log（重做日志）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;具体介绍&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[29,30],&quot;f&quot;:true},&quot;v&quot;:&quot;redo log&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,31],&quot;f&quot;:true},&quot;v&quot;:&quot;update工作流程&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[31,32],&quot;f&quot;:true},&quot;v&quot;:&quot;先向内存中Buffer pool中拿目标对象&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[32,33],&quot;f&quot;:true},&quot;v&quot;:&quot;发现没有，从磁盘数据页中取出，放入缓冲区中&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[33,34],&quot;f&quot;:true},&quot;v&quot;:&quot;缓冲区数据变更&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[34,35],&quot;f&quot;:true},&quot;v&quot;:&quot;将变更记录在内存redo log buffer中&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[35,36],&quot;f&quot;:true},&quot;v&quot;:&quot;同步redo log buffer至 redo log中&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[36,37],&quot;f&quot;:true},&quot;v&quot;:&quot;隔一段时间将缓冲区的数据同步至磁盘中&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[37,38],&quot;f&quot;:true},&quot;v&quot;:&quot;同步失败，找redo log重新执行，保证持久性&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[38,39],&quot;f&quot;:true},&quot;v&quot;:&quot;先写日志（WAL）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[39,40],&quot;f&quot;:true},&quot;v&quot;:&quot;update同步缓冲到磁盘数据页中&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[40,41],&quot;f&quot;:true},&quot;v&quot;:&quot;是随机io，要找很久，而redo log buffer&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[41,42],&quot;f&quot;:true},&quot;v&quot;:&quot;同步到磁盘中redo log中 是 顺序io，直接日志追加&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[42,43],&quot;f&quot;:true},&quot;v&quot;:&quot;作用：脏页刷新失败后重做，保证持久性&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[43,44],&quot;f&quot;:true},&quot;v&quot;:&quot;组成：redo log buffer（内存） 和 redo log（磁盘）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[44,45],&quot;f&quot;:true},&quot;v&quot;:&quot;特性：2个文件，循环追加，定时清理&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[46,47],&quot;f&quot;:true},&quot;v&quot;:&quot;undo log&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[47,48],&quot;f&quot;:true},&quot;v&quot;:&quot;作用：提供了事务回滚机制，辅助MVCC&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[48,49],&quot;f&quot;:true},&quot;v&quot;:&quot;创建：当执行数据变更语句时，记录&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[49,50],&quot;f&quot;:true},&quot;v&quot;:&quot;销毁：事务提交后不会立刻删除，辅助MVCC&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[50,51],&quot;f&quot;:true},&quot;v&quot;:&quot;insert时，事务提交后直接删除&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[51,52],&quot;f&quot;:true},&quot;v&quot;:&quot;update和delete时，MVCC在快照读时需要，不删除&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[52,53],&quot;f&quot;:true},&quot;v&quot;:&quot;记录机制：逻辑日志，delete时，记录insert&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[54,55],&quot;f&quot;:true},&quot;v&quot;:&quot;MVCC&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[55,56],&quot;f&quot;:true},&quot;v&quot;:&quot;当前读：读取最新数据，同时对数据加锁，其他事物无法修改&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[56,57],&quot;f&quot;:true},&quot;v&quot;:&quot;select in share mode&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[57,58],&quot;f&quot;:true},&quot;v&quot;:&quot;select for update&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[58,59],&quot;f&quot;:true},&quot;v&quot;:&quot;update,delete,insert&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[59,60],&quot;f&quot;:true},&quot;v&quot;:&quot;快照读：简单select，不加锁，读取数据可见版本&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[60,61],&quot;f&quot;:true},&quot;v&quot;:&quot;Read Commit：每次select都生成一个快照&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[61,62],&quot;f&quot;:true},&quot;v&quot;:&quot;Repeatable Read：开始事物后第一个select生成快照&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[62,63],&quot;f&quot;:true},&quot;v&quot;:&quot;Serializable：全是当前读&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[63,64],&quot;f&quot;:true},&quot;v&quot;:&quot;隐藏字段&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[64,65],&quot;f&quot;:true},&quot;v&quot;:&quot;DB_TRX_ID:最新修改事物id&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[65,66],&quot;f&quot;:true},&quot;v&quot;:&quot;DB_ROLL_PTR:回滚指针，指向记录的上一个版本，undo log中的地址&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[66,67],&quot;f&quot;:true},&quot;v&quot;:&quot;DB_ROW_ID:隐藏主键，当没有主键时才创建&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[67,68],&quot;f&quot;:true},&quot;v&quot;:&quot;undo log&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[68,69],&quot;f&quot;:true},&quot;v&quot;:&quot;作用：不同事物或相同事物对同一条记录修改&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[69,70],&quot;f&quot;:true},&quot;v&quot;:&quot;会导致unlog生成一条按时间顺序的版本链&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[70,71],&quot;f&quot;:true},&quot;v&quot;:&quot;配合readview来找出当前读时选择的版本链&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[71,72],&quot;f&quot;:true},&quot;v&quot;:&quot;rereadview&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[72,73],&quot;f&quot;:true},&quot;v&quot;:&quot;作用：给快照读提供依据，根据规则找到对应版本的undo log记录&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[73,74],&quot;f&quot;:true},&quot;v&quot;:&quot;创建：RC时，每次读都会生成，RR时，第一次才会生成，后续复用&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[74,75],&quot;f&quot;:true},&quot;v&quot;:&quot;核心字段&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[75,76],&quot;f&quot;:true},&quot;v&quot;:&quot;m_ids:当前活鱼事务id集合&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[76,77],&quot;f&quot;:true},&quot;v&quot;:&quot;min_trx_id:最小活跃事务id&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[77,78],&quot;f&quot;:true},&quot;v&quot;:&quot;max_trx_id:下一个事物id&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[78,79],&quot;f&quot;:true},&quot;v&quot;:&quot;creator_trx_id : readView创建者的id&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[79,80],&quot;f&quot;:true},&quot;v&quot;:&quot;规则&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[80,81],&quot;f&quot;:true},&quot;v&quot;:&quot;trx_id == creator_trx_id 可以访问。说明这个数据是自己事物改的&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[81,82],&quot;f&quot;:true},&quot;v&quot;:&quot;trx_id &amp;lt; min_trx_id 可以访问。说明访问的数据已经提交了&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[82,83],&quot;f&quot;:true},&quot;v&quot;:&quot;trx_id &amp;gt; max_trx_id 不可以访问。说明数据是在创建之后事物的&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[83,84],&quot;f&quot;:true},&quot;v&quot;:&quot;trx_id &amp;lt;= max_trx_id 并且 trx_id 不在m_ids中，可以访问，说明数据已经提交了&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[85,86],&quot;f&quot;:true},&quot;v&quot;:&quot;锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[86,87],&quot;f&quot;:true},&quot;v&quot;:&quot;策略划分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[87,88],&quot;f&quot;:true},&quot;v&quot;:&quot;乐观锁：自主代码实现，数据库不参与&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[88,89],&quot;f&quot;:true},&quot;v&quot;:&quot;悲观锁：数据库内部实现&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[89,90],&quot;f&quot;:true},&quot;v&quot;:&quot;范围划分&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[90,91],&quot;f&quot;:true},&quot;v&quot;:&quot;全局锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[91,92],&quot;f&quot;:true},&quot;v&quot;:&quot;用于数据库备份，需要手动敲命令&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[92,93],&quot;f&quot;:true},&quot;v&quot;:&quot;问题&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[93,94],&quot;f&quot;:true},&quot;v&quot;:&quot;主库上，数据无法变更，影响业务&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[94,95],&quot;f&quot;:true},&quot;v&quot;:&quot;从库上，主从同步延迟，无法保障一致性&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[95,96],&quot;f&quot;:true},&quot;v&quot;:&quot;表级锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[96,97],&quot;f&quot;:true},&quot;v&quot;:&quot;表锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[97,98],&quot;f&quot;:true},&quot;v&quot;:&quot;加锁：lock table 表名 read/write&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[98,99],&quot;f&quot;:true},&quot;v&quot;:&quot;解锁：unlock tables 表名 / 断开客户端&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[99,100],&quot;f&quot;:true},&quot;v&quot;:&quot;分类：表共享读锁，表共享写锁&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[100,101],&quot;f&quot;:true},&quot;v&quot;:&quot;规则：读锁：所有客户端可读不可写，写锁：当前可读可写&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[101,102],&quot;f&quot;:true},&quot;v&quot;:&quot;元数据锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[102,103],&quot;f&quot;:true},&quot;v&quot;:&quot;作用：让增删改与修改表结构不冲突&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[103,104],&quot;f&quot;:true},&quot;v&quot;:&quot;分类：共享锁，排他锁&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[104,105],&quot;f&quot;:true},&quot;v&quot;:&quot;加锁：增删改查时共享锁，修改表结构时排他锁&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[105,106],&quot;f&quot;:true},&quot;v&quot;:&quot;规则：排他锁和其他互斥&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[106,107],&quot;f&quot;:true},&quot;v&quot;:&quot;意向锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[107,108],&quot;f&quot;:true},&quot;v&quot;:&quot;作用：表锁行锁冲突时，扫描整个表来判断是否有行锁性能太低，意向锁来直接判断是否可以加锁&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[108,109],&quot;f&quot;:true},&quot;v&quot;:&quot;分类：意向排他锁（IS），意向共享锁（IX）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[109,110],&quot;f&quot;:true},&quot;v&quot;:&quot;加锁：IS：select share in mode IX：增删改，select for update&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[110,111],&quot;f&quot;:true},&quot;v&quot;:&quot;规则：IS与表读锁兼容，与表写锁互斥，IX与表锁都互斥，意向锁之间没啥制约关系&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[111,112],&quot;f&quot;:true},&quot;v&quot;:&quot;行级锁&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[112,113],&quot;f&quot;:true},&quot;v&quot;:&quot;说明：InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[113,114],&quot;f&quot;:true},&quot;v&quot;:&quot;行锁：锁单个行记录，防止其他事物修改。RC，RR支持&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[114,115],&quot;f&quot;:true},&quot;v&quot;:&quot;共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:6,&quot;p&quot;:{&quot;lines&quot;:[115,116],&quot;f&quot;:true},&quot;v&quot;:&quot;排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[116,117],&quot;f&quot;:true},&quot;v&quot;:&quot;间隙锁：锁记录的间隙，防止其他事物插入，产生幻读。RR支持&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[117,118],&quot;f&quot;:true},&quot;v&quot;:&quot;临键锁：行锁和间隙锁组合，RR支持&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[118,119],&quot;f&quot;:true},&quot;v&quot;:&quot;默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引|(扫描，以防止幻读。&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[119,120],&quot;f&quot;:true},&quot;v&quot;:&quot;1. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[120,121],&quot;f&quot;:true},&quot;v&quot;:&quot;2. InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[121,122],&quot;f&quot;:true},&quot;v&quot;:&quot;3. 索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁。&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[122,123],&quot;f&quot;:true},&quot;v&quot;:&quot;4. 索引上的等值查询(普通索引)，next-key lock退化为间隙锁，锁自己值和左右间隙&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[123,124],&quot;f&quot;:true},&quot;v&quot;:&quot;5. 索引上的范围查询(唯一索引)，其范围内的，到第一个不满足的值间隙，自己的值都会加锁&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[124,125],&quot;f&quot;:true},&quot;v&quot;:&quot;6. 间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。&quot;}]}]}]}]}],&quot;p&quot;:{}}"></svg>
</div>





<h2 id="Mysql管理"><a href="#Mysql管理" class="headerlink" title="Mysql管理"></a><strong>Mysql管理</strong></h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a><strong>系统数据库</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220621132624873.png" width="100%" / loading="lazy">

<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a><strong>mysql</strong></h3><pre><code>    语法:
            mysql [options] [database]
    选项:
            -u,--user=name                        #指定用户名
            -p,--password[=name]          #指定密码
            -h,--host=name                        #指定服务器ip和域名
            -P,--port=port                        #指定连接端口 
            -e,--execute=name                    #执行sql语句并退出
    实例：使用-e执行sql语句，而不用连接mysql再执行，对处理shell方便
            mysql -uroot -p123456 db01 -e “select * from stu”;    
</code></pre>
<h3 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a><strong>mysqladmin</strong></h3><pre><code>    介绍:
            mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。
    实例1:删除数据库
            mysqladmin -uroot -p1234 drop db02
    实例2:查看mysql版本
            mysqladmin -uroot -p1234 version
</code></pre>
<h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a><strong>mysqlbinlog</strong></h3><pre><code>    语法:
            mysqlbinlog [options] log-files1 log-files2 ...
    选项:
            -d,--database=name                指定数据库名称,只列出指定的数据库相关操作
            -o,--offset=#                            忽略掉日志中的前n行命令
            -r,--result-file=name          将输出的文本格式日志输出到指定文件。
            -s, --short-form                    显示简单格式，省略掉一些信息。
            --start-datatime=datel --stop-datetime=date2     指定日期间隔内的所有日志。
            --start-position=posl --stop-position=pos2        指定位置间隔内的所有日志。
</code></pre>
<h3 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a><strong>mysqlshow</strong></h3><pre><code>    介绍：        
            mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。
    语法：
            mysqlshow [options] [db_name[table_name[col_name]]
    选项： 
            --count 显示数据库，表，的统计信息
            -i            显示指定数据库或者指定表的状态信息
    实例：
            查询mysql数据库信息
            mysqlshow -uroot -p1234 --count
            
            查询test库中每个表中的字段数，及行数
            mysqlshow -uroot -p1234 test --count
            
            查询test库中book表的详细情况
            mysqlshow -uroot -p1234 test book --count
</code></pre>
<h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a><strong>mysqldump</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220621162235073.png" width="100%" / loading="lazy">

<h3 id="mysqlimport-source"><a href="#mysqlimport-source" class="headerlink" title="mysqlimport/source"></a><strong>mysqlimport/source</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220621163153114.png" width="100%" / loading="lazy">

<h1 id="运维篇"><a href="#运维篇" class="headerlink" title="运维篇"></a><strong>运维篇</strong></h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a><strong>错误日志</strong></h3><pre><code>    错误日志是 MySQL 中最重要的日志之一，它记录了当mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息
    当数据库出现任何故障导致无法正常使用时，建议首先查看此日志。

    该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log。查看日志位置：
    show variables like&#39;%log_error%’
</code></pre>
<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a><strong>二进制日志</strong></h3><pre><code>    二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询(SELECT、 show)语句。

    作用：
            ①灾难时的数据恢复；
            ②MySQL的主从复制。在MySQL3版本中，默认二进制日志是开启着的，涉及到的参数如下：
            show variables like&#39;%log_bin%
            文件： 
            | log_bin_basename                | /var/lib/mysql/binlog       | 二进制文件存放位置，binlog001文件名等依次递增
            | log_bin_index                   | /var/lib/mysql/binlog.index | 索引文件，里面记录了所有的二进制文件列表

    日志查看：
                由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具mysqlbinlog来查看
            语法：mysqlbinlog [参数选项] logfilename    
            参数选项：
                -d        指定数据库名称,只列出指定的数据库相关操作
                -o        忽略掉日志中的前n行命令。
                -v        将行事件(数据变更)重构为sql语句
                -W        将行事件(数据变更)重构为sql语句，并输出注释信息
    查看日志格式：
            show variables like &#39;%binlog_format%’
    修改日志格式:
            在/etc/my.cnf 添加binlog_format=
    日志删除
            对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：
            也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。默认30天
            show variables like ‘%binlog_expire_logs_seconds%’;
</code></pre>
<img src="http://hexo.xuxin.world/mysql/image-20220622101706490.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220622104826321.png" width="100%" / loading="lazy">

<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a><strong>查询日志</strong></h3><pre><code>    介绍：
            由于二进制日志是DDL与DML语句的记录，DQL则没有记录，查询日志记录了DQL语句，但默认是关闭的
    查看查询日志相关
            show variables like ‘%general%’;
    修改查询日志参数
            vim /etc/my.cnf 添加 参数
    查询日志相关参数
            general_log              表示关还是开
            general_log_file          表示存放在哪
</code></pre>
<h3 id="慢查询日志-1"><a href="#慢查询日志-1" class="headerlink" title="慢查询日志"></a><strong>慢查询日志</strong></h3><pre><code>    慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit
    的所有的SQL语句的日志，默认未开启。long_query_time 默认为 10 秒，最小为 0，精度可以到微秒。

        #慢查询日志
        slow_query_log=1
        #执行时间参数
        long_query_time=2

    默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用log_slow_admin_statements和
    更改此行为 log_queries_not_using_indexes，如下所述。

        #记录执行较慢的管理语句
        log_slow_admin_ statements =1
        #记录执行较慢的未使用索引的语句
        log_queries_ not_ using_indexes =1
</code></pre>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><strong>主从复制</strong></h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a><strong>概述</strong></h3><pre><code>    - 概述
        主从复制是指将主数据库的DDL 和 DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。
        MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。

    - 优点
        1.主库出现问题，可以快速切换到从库提供服务。
        2.实现读写分离，降低主库的访问压力。
        3.可以在从库中执行备份，以避免备份期间影响主库服务。
</code></pre>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h3><img src="http://hexo.xuxin.world/mysql/image-20220622144220884.png" width="100%" / loading="lazy">

<pre><code>    从上图来看，复制分成三步：
        1.Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中
        2.从库读取主库的二进制日志文件 Binlog，写入到从库的中继日志 Relay Log
        3.slave重做中继日志中的事件，将改变反映它自己的数据。
</code></pre>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a><strong>搭建</strong></h3><blockquote>
<ul>
<li>准备工作</li>
<li>主库配置</li>
<li>从库配置</li>
<li>验证</li>
</ul>
</blockquote>
<ul>
<li><p>主库修改</p>
<pre><code>  - 修改主库/etc/my.cnf
          #mysqlL服务ID，保证整个集群环境中唯一，取值范围：1-232-1，默认为1
          server-id=1
          #是否只读,1代表只读，0代表读写
          read-only=0
          
          #忽略的数据，指不需要同步的数据库
          #binlog-ignore-db=mysql
          #指定同步的数据库
          #binlog-do-db=dbo1

  - 重启mysql
          systemctl restart mysqld

  - 登录mysql，创建远程连接的账号，并授予主从复制权限
          #创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务
          CREATE USER &#39;xuxin&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Xuxin@1234’;
          #为xuxin&#39;@&#39;%用户分配主从复制权限
          GRANT REPLICATION SLAVE ON *.* TO &#39;itcast&#39;@&#39;%&#39;;

  - 查看二进制日志坐标
          show master status;
          包含以下字段：
          file：从哪个日志文件开始推送日志文件
          position：从哪个位置开始推送日志
          binlog_ignore_db：指定不需要同步的数据库
</code></pre>
</li>
</ul>
<ul>
<li><p>从库修改</p>
<pre><code>  - 修改从库/etc/my.cnf
          #mysqlL服务ID，保证整个集群环境中唯一，取值范围：1-232-1，默认为1
          server-id=2
          #是否只读,1代表只读，0代表读写
          read-only=1
          
          #忽略的数据，指不需要同步的数据库
          #binlog-ignore-db=mysql
          #指定同步的数据库
          #binlog-do-db=dbo1
          #只读只是对于普通用户来说的，超级管理员也是可以写的，如果禁用需要添加以下配置
          #super-read-only=1

  - 重启mysql
          systemctl restart mysqld

  - 登录mysql，设置主库配置
          CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#39;主库ip&#39;,SOURCE_USER=&#39;连接主库用户名&#39;,SOURCE_PASSWORD=&#39;连接主库的密码&#39;, SOURCE_LOG_FILE=&#39;开始主从复制的binlog日志文件名&#39;, SOURCE_LOG_POS=binlog文件位置;
      
          注意：上述是8.0.23中的语法。如果mysql是8.0.23之前的版本，执行如下sql
          CHANGE MASRTER TO MASTER_HOST=&#39;主库ip&#39;,MASTER_USER=&#39;用户名&#39;,MASTER_PASSWORD=&#39;密码&#39;,MASTER_LOG_FILE=&#39;binlog文件名&#39;,MASTER_LOG_POS=&#39;binlog位置&#39;;
          
  - 开启同步操作
          start replica;        #8.0.22之后
          start slave;            #8.0.22之前

  - 查看主从同步状态
          show replica status\G;        #8.0.22之后
          show slave status\G;            #8.0.22之前
          注意：只要以下2个参数正常即可，代表一个是io线程运行正常，一个是sql线程正常
          replica_IO_Running:Yes
          Replica_SQL_Running:Yes
</code></pre>
</li>
</ul>
<img src="http://hexo.xuxin.world/mysql/image-20220622151841459.png" width="100%" / loading="lazy">

<blockquote>
<p><strong>注意事项：主从复制是从当前位置开始的，如果主库之前有数据，应该先转成sql脚本在从库中运行，再进行主从复制</strong></p>
</blockquote>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a><strong>分库分表</strong></h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a><strong>概述</strong></h3><ul>
<li>原始数据库的问题<pre><code>  磁盘io，网络io，cpu压力大
</code></pre>
</li>
<li>拆分策略<pre><code>  垂直拆分库：以表为单位，放到不同的数据库中
  水平拆分库：以字段为单位，将不同字段分到不同的表中
  垂直拆分表：以数据为单位，把库中数据分散到其他库中，库中有多个表
  水平拆分表：以数据为单位，把表中数据分散到其他库中，库中有1个表
</code></pre>
</li>
<li>实现技术<pre><code>  shardingJDBC： 基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。
  Mycat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。
</code></pre>
</li>
</ul>
<img src="http://hexo.xuxin.world/mysql/image-20220622163256618.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220622163615173.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220622164125006.png" width="100%" / loading="lazy">


<h3 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a><strong>mycat</strong></h3><ul>
<li>介绍<pre><code>  Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。
</code></pre>
</li>
<li>优势<pre><code>  性能可靠稳定
  强大的技术团队
  体系完善
  社区活跃
</code></pre>
</li>
<li>下载<pre><code>  1.官网下载http://www.mycat.org.cn/
  2.解压到/usr/local下
  3.进入mycat的lib目录下，找到mysql驱动jar包删除
  4.上传mysql8.0以上的jar包到lib目录
</code></pre>
</li>
<li>目录结构<pre><code>  bin ： 存放可执行文件，用于启动停止mycat
  conf：存放mycat的配置文件
  lib： 存放mycat的项目依赖包 （jar)
  logs：存放mycat的日志文件
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>安装jdk—-配置环境变量</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8.0_171</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p><strong>mycat概念图</strong></p>
<img src="http://hexo.xuxin.world/mysql/image-20220623092713677.png" width="100%" / loading="lazy">

<blockquote>
<p><strong>mychat配置</strong></p>
</blockquote>
<p><strong>schema.xml配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;100&quot; randomDataNode=&quot;dn1&quot;&gt;</span><br><span class="line">		&lt;table name=&quot;travelrecord,address&quot; dataNode=&quot;dn1,dn2&quot; rule=&quot;auto-sharding-long&quot; splitTableNames =&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/schema&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dataNode name=&quot;dn1&quot; dataHost=&quot;dhost1&quot; database=&quot;db01&quot; /&gt;</span><br><span class="line">	&lt;dataNode name=&quot;dn2&quot; dataHost=&quot;dhost2&quot; database=&quot;db01&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;dataHost name=&quot;dhost1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;</span><br><span class="line">			  writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;jdbc&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;</span><br><span class="line">		&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">		&lt;writeHost host=&quot;hostM1&quot; url=&quot;jdbc:mysql://43.142.107.197?useSSL=false&amp;amp;serverTimezone=Asiz/Shanghai&amp;amp;characterEncoding=utf8&quot; user=&quot;root&quot;</span><br><span class="line">				   password=&quot;1234&quot;&gt;</span><br><span class="line">		&lt;/writeHost&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/dataHost&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;dataHost name=&quot;dhost2&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;</span><br><span class="line">			  writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;jdbc&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;</span><br><span class="line">		&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">		&lt;writeHost host=&quot;hostM1&quot; url=&quot;jdbc:mysql://101.200.39.91?useSSL=false&amp;amp;serverTimezone=Asiz/Shanghai&amp;amp;characterEncoding=utf8&quot; user=&quot;root&quot;</span><br><span class="line">				   password=&quot;hxuxingy12&quot;&gt;</span><br><span class="line">		&lt;/writeHost&gt;</span><br><span class="line">	&lt;/dataHost&gt;</span><br><span class="line">&lt;/mycat:schema&gt;</span><br></pre></td></tr></table></figure>

<p><strong>配置server.xml，修改密码和schemas</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;defaultSchema&quot;&gt;TESTDB&lt;/property&gt;</span><br><span class="line">&lt;/user&gt;</span><br><span class="line"></span><br><span class="line">&lt;user name=&quot;user&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;defaultSchema&quot;&gt;TESTDB&lt;/property&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<h4 id="mycat配置文件"><a href="#mycat配置文件" class="headerlink" title="mycat配置文件"></a><strong>mycat配置文件</strong></h4><p><strong>schema.xml</strong></p>
<pre><code>    schema.xml 作为MyCat中最重要的配置文件之一，涵盖了MyCat的逻辑库、逻辑表、分片规则、分片节点及数据源的配置。
    主要包含以下三组标签：
    schema标签            --逻辑库、逻辑表、包含的结点、用什么规则
    datanode标签        --结点信息
    datahost标签        --数据源信息
</code></pre>
<ul>
<li>schema<pre><code>  核心属性：
  name： 指定自定义的逻辑库库名，区分大小写
  checkSQLschema：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除
  sqlMaxLimit：如果未指定limit进行查询，则只查这个数
</code></pre>
</li>
<li>table<pre><code>  核心属性：
  name：定义逻辑表表名，在该逻辑库下唯一
  dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔
  rule：分片规则的名字，分片规则名字是在rule.xm[中定义的
  primarykey： 逻辑表对应真实表的主键
  type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配置为 global
</code></pre>
</li>
<li>dataNode<pre><code>  核心属性：
  name：定义数据节点名称
  dataHost：数据库实例主机名称，引用自 dataHost 标签中name属性
  database： 定义分片所属数据库
</code></pre>
</li>
<li>dbDriver<pre><code>  核心属性：
  name：唯一标识，供上层标签使用
  maxCon/minCon：最大连接数/最小连接数
  balance：负载均衡策略，取值0,1,2,3）
  writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）
  dbDriver：数据库驱动，支持 native、 jdbc
</code></pre>
</li>
</ul>
<img src="http://hexo.xuxin.world/mysql/image-20220628223754338.png" width="100%" / loading="lazy">

<p><strong>rule.xml</strong></p>
<pre><code>    rule.xm/中定义所有拆分表的规则,在使用过程中可以灵活的使用分片算法，或者对同一个分片算法使用不同的参数，它让分片过程可配
    置化。主要包含两类标签：tableRule、 Function。
</code></pre>
<p><strong>server.xml</strong></p>
<img src="http://hexo.xuxin.world/mysql/image-20220628224340402.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628224315561.png" width="100%" / loading="lazy">

<h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a><strong>垂直分库</strong></h4><blockquote>
<ul>
<li>多表联查中所有的表只能在同一个结点上</li>
<li>可以将字典类型的表设置为全局表，以方便多表联查</li>
<li>全局表在所有结点上都存在且修改动全部</li>
</ul>
</blockquote>
<h4 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a><strong>分片规则</strong></h4><h5 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a><strong>范围分片</strong></h5><img src="http://hexo.xuxin.world/mysql/image-20220628231518331.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628231651860.png" width="100%" / loading="lazy">


<h5 id="取模分片"><a href="#取模分片" class="headerlink" title="取模分片"></a><strong>取模分片</strong></h5><img src="http://hexo.xuxin.world/mysql/image-20220628231810340.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628231854778.png" width="100%" / loading="lazy">

<h5 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a><strong>一致性哈希</strong></h5><img src="http://hexo.xuxin.world/mysql/image-20220628232121270.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628232444533.png" width="100%" / loading="lazy">


<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h5><img src="http://hexo.xuxin.world/mysql/image-20220628232759934.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628232708998.png" width="100%" / loading="lazy">


<h4 id="应用指定"><a href="#应用指定" class="headerlink" title="应用指定"></a><strong>应用指定</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220628233248849.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628233304222.png" width="100%" / loading="lazy">


<h4 id="固定分片-hash算法"><a href="#固定分片-hash算法" class="headerlink" title="固定分片-hash算法"></a><strong>固定分片-hash算法</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220628233820501.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628234023488.png" width="100%" / loading="lazy">


<h4 id="字符串hash解析"><a href="#字符串hash解析" class="headerlink" title="字符串hash解析"></a><strong>字符串hash解析</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220628234640756.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628234944579.png" width="100%" / loading="lazy">


<h4 id="按天分片"><a href="#按天分片" class="headerlink" title="按天分片"></a><strong>按天分片</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220628235201813.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628235320598.png" width="100%" / loading="lazy">


<h4 id="按自然月分片"><a href="#按自然月分片" class="headerlink" title="按自然月分片"></a><strong>按自然月分片</strong></h4><img src="http://hexo.xuxin.world/mysql/image-20220628235538984.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220628235633481.png" width="100%" / loading="lazy">


<h3 id="mycat的管理与监控"><a href="#mycat的管理与监控" class="headerlink" title="mycat的管理与监控"></a><strong>mycat的管理与监控</strong></h3><p><strong>插入流程</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629000323248.png" width="100%" / loading="lazy"></p>
<p><strong>查询流程</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629000358001.png" width="100%" / loading="lazy"></p>
<p><strong>mycat管理</strong></p>
<pre><code>    Mycat默认开通2个端口，可以在serverxml中进行修改。
        - 8066 数据访问端口，即进行 DML 和 DDL操作。
        - 9066数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态
    mysql -h 192.168.200.210 -p 9066 -uroot -p123456
</code></pre>
<img src="http://hexo.xuxin.world/mysql/image-20220629000638443.png" width="100%" / loading="lazy">

<p><strong>mycat管理的图形化界面</strong></p>
<pre><code>    Mycat-eye
    - 介绍
            Myeatwecb(ryateye)是对myatseves提供蔬控服务，功能不局限于对myatsever使用，
            他通过IDec莲接对wveat、 MAeA监控，监控远程服务器(目前仅限于linux系统)的cpu、内存、网络、磁盘。
            Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。
    - 安装
            Zookeeper安装
            MyCat-web安装
    - 访问
            ip:端口/mycat
</code></pre>
<img src="http://hexo.xuxin.world/mysql/image-20220629002311075.png" width="100%" / loading="lazy">

<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h2><img src="http://hexo.xuxin.world/mysql/image-20220629093836872.png" width="100%" / loading="lazy">
<img src="http://hexo.xuxin.world/mysql/image-20220629094116269.png" width="100%" / loading="lazy">

<ul>
<li>介绍<pre><code>  读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。
  主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。
  通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server
</code></pre>
</li>
</ul>
<h3 id="一主一丛"><a href="#一主一丛" class="headerlink" title="一主一丛"></a><strong>一主一丛</strong></h3><blockquote>
<ul>
<li><strong>先搭建主从复制</strong></li>
<li><strong>再搭建读写分离</strong></li>
</ul>
</blockquote>
<p><strong>配置主从宿主机</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629094621248.png" width="100%" / loading="lazy"></p>
<p><strong>配置负载均衡策略</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629094823250.png" width="100%" / loading="lazy"></p>
<p><strong>问题：主节点Master宕机之后，业务系统就只能够读，而不能写入数据了。</strong></p>
<h3 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a><strong>双主双从</strong></h3><pre><code>    一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从机 Slave2 负责所有读请求。
    当 Master1主机宕机后，Master2 主机负责写请求，Master1、Master2 互为备机。架构图如下：
</code></pre>
<img src="http://hexo.xuxin.world/mysql/image-20220629095747304.png" width="100%" / loading="lazy">

<p><strong>搭建</strong></p>
<p><strong>主1配置</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629100215918.png" width="100%" / loading="lazy"></p>
<p> <strong>主2配置</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629100315109.png" width="100%" / loading="lazy"></p>
<p><strong>主库分别创建用户并授权</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629100402781.png" width="100%" / loading="lazy"></p>
<p><strong>从库配置</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629100529260.png" width="100%" / loading="lazy"></p>
<p><strong>从库关联主库并查看状态</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629100630444.png" width="100%" / loading="lazy"></p>
<p><strong>主主之间主从复制</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629100842850.png" width="100%" / loading="lazy"></p>
<p><strong>mycat读写分离的配置</strong><br><img src="http://hexo.xuxin.world/mysql/image-20220629101204517.png" width="100%" / loading="lazy"><br><img src="http://hexo.xuxin.world/mysql/image-20220629101426171.png" width="100%" / loading="lazy"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h1><h2 id="AOP记录日志"><a href="#AOP记录日志" class="headerlink" title="AOP记录日志"></a><strong>AOP记录日志</strong></h2><h2 id="系统性能优化"><a href="#系统性能优化" class="headerlink" title="系统性能优化"></a><strong>系统性能优化</strong></h2><h2 id="MySQL中的ORDER-BY-field"><a href="#MySQL中的ORDER-BY-field" class="headerlink" title="MySQL中的ORDER BY field"></a><strong>MySQL中的ORDER BY field</strong></h2><pre><code>    MySQL可以通过field()函数自定义排序

    - 格式
            field(value,str1,str2,str3,str4)
    - 说明
            value与str1、str2、str3、str4比较，返回1、2、3、 4
            如遇到不在列表中的数据则排序在最前，且按照主键递增排序

            如果desc倒序了，倒序时，按照str3，str2，str1的顺序逆向排序，不在str1，str2，str3中的记录放到最后；str值相同按主键顺序排列
</code></pre>
<h2 id="配置文件参数"><a href="#配置文件参数" class="headerlink" title="配置文件参数"></a><strong>配置文件参数</strong></h2><h2 id="事件-定时任务"><a href="#事件-定时任务" class="headerlink" title="事件(定时任务)"></a><strong>事件(定时任务)</strong></h2><ul>
<li><p>概念</p>
<pre><code>  MySQL5.1版本开始引进event概念，MySQL 中的事件(event：时间触发器)是用于执行定时或周期性的任务，类似Linux中的crontab
  但是后者只能精确到分钟，事件可以精确到秒。通过单独或调用存储过程使用，在某一特定的时间点，触发相关的SQL语句或存储过程。
  事件由一个特定的线程来管理的，也就是所谓的事件调度器，但是事件不能直接调用。
</code></pre>
</li>
<li><p>使用</p>
<pre><code>  MySQL中调度器event_scheduler负责调用事件，也就是由全局变量event_scheduler的状态决定，它默认是OFF, 一般是OFF。

      打开：SET GLOBAL event_scheduler=1/ON
      关闭：SET GLOBAL event_scheduler=0/OFF
      创建：
          --语法
              CREATE
                  [DEFINER=&#123;user | CURRENT_USER&#125;]            可选，用于定义事件执行时检查权限的用户
                  EVENT [IF NOT EXISTS] event_name        
                  ON SCHEDULE schedule                    用于定义执行的时间和时间间隔
                  [ON COMPLETION [NOT] PRESERVE]            用于定义事件是否循环执行
                  [ENABLE | DISABLE | DISABLE ON SLAVE]    用于定义事件是否活动的
                  [COMMENT &#39;comment&#39;]                        用于定义事件的注释
                  DO event_body;                            event_body表示SQL，存储过程或者begin...end

          --schedule说明

              AT timestamp [+ INTERVAL interval] ...
              | EVERY interval
                  [STARTS timestamp [+ INTERVAL interval] ...]
                  [ENDS timestamp [+ INTERVAL interval] ...]

          --参数说明：

              （1）timestamp：表示一个具体的时间点，后面加上一个时间间隔，表示在这个时间间隔后事件发生。

              （2）EVERY子句：用于表示事件在指定时间区间内每隔多长时间发生一次，其中 SELECT子句用于指定开始时间；
               ENDS子句用于指定结束时间。

              （3）interval：表示一个从现在开始的时间，其值由一个数值和单位构成。例如，使用“4 WEEK”表示4周；
               使用“‘1:10’ HOUR_MINUTE”表示1小时10分钟。间隔的距离用DATE_ADD()函数来支配。

          --interval参数值的语法格式：
              quantity &#123;YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
                          WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
                          DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND&#125;

          --些常用的时间间隔设置：

              （1）每隔5秒钟执行
                      ON SCHEDULE EVERY 5 SECOND
              （2）每隔1分钟执行
                      ON SCHEDULE EVERY 1 MINUTE
              （3）每天凌晨1点执行
                      ON SCHEDULE EVERY 1 DAY STARTS DATE_ADD(DATE_ADD(CURDATE(), INTERVAL 1 DAY), 
                      INTERVAL 1 HOUR)
              （4）每个月的第一天凌晨1点执行
                      ON SCHEDULE EVERY 1 MONTH STARTS DATE_ADD(DATE_ADD(DATE_SUB(CURDATE(),
                      INTERVAL DAY(CURDATE())-1 DAY),INTERVAL 1 MONTH),INTERVAL 1 HOUR)

      启动与关闭: ALTER EVENT event_user ENABLE/DISABLE;        
      删除事件: DROP EVENT IF EXISTS event_user;        
      修改事件:
              ALTER
                  [DEFINER=&#123;user | CURRENT_USER&#125;]
                  EVENT [IF NOT EXISTS] event_name
                  ON SCHEDULE schedule
                  [ON COMPLETION [NOT] PRESERVE]
                  [ENABLE | DISABLE | DISABLE ON SLAVE]
                  [COMMENT &#39;comment&#39;]
                  DO event_body;
     查询事件: SELECT * FROM information_schema.events; 
</code></pre>
</li>
<li><p>辅助命令</p>
<pre><code>  查看事件调度器是否开启
          show variables like &#39;%event_scheduler%&#39;;
  查看调度器线程
          show processlist;
</code></pre>
</li>
<li><p>注意事项</p>
<pre><code>  1 主库已执行过，从库上务必保证event不会执行(除非故意在slave上创建的event)
  2 创建，删除等操作严禁直接操作mysql.event表，而是通过create等正规语法实现
  3 创建的event涉及到海量数据变更的话，要做好充分测试，确保不影响现网服务
  4 如果需要备份带有event的DB，mysqldump时需要加上--event参数
</code></pre>
</li>
</ul>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><ol>
<li><p>介绍</p>
<pre><code> 表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。
 从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。
 
</code></pre>
</li>
<li><p>表分区与分表的区别</p>
<pre><code> 分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。 
 分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。
</code></pre>
</li>
<li><p>为什么用分区表的少</p>
<pre><code> 1 分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁
 2 一旦数据量并发量上来，如果在分区表实施关联，就是一个灾难
 3 自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控
 4 运维麻烦
</code></pre>
</li>
<li><p>分区表的限制因素</p>
<pre><code> （1）一个表最多只能有1024个分区。
 （2）查询条件里需包含分区键
 （3）分区键必须作为主键的一部分，因此分区键建议与原来表id作为联合主键。
 （4）分区表中无法使用外键约束。
 （5）分区的字段，必须是表上所有的唯一索引（或者主键索引）包含的字段的子集
 （6）range分区：分区字段必须是整型或者转换为整型，
</code></pre>
</li>
<li><p>实例：每日按照日期增加分区</p>
<pre><code> - 查看是否支持表分区
     SHOW VARIABLES LIKE &#39;%partition%&#39;

 - 创建表
     create table time_partition
     (
         id   int auto_increment,
         data varchar(255) null,
         time datetime     not null,
         primary key (id, time)
     )partition by range (to_days(`time`));

 - 查询表的所有分区名
     SELECT a.PARTITION_NAME
     FROM information_schema.PARTITIONS a
     WHERE a.table_name = &#39;time_partition&#39;
     ORDER BY partition_ordinal_position DESC;
     
 - 添加新分区
     alter table time_partition add partition(partition p19800101 values less than (&#39;19800101&#39;))

 - 更改主键
     ALTER TABLE time_partition DROP PRIMARY KEY, ADD PRIMARY KEY (`id`, `insert_time`);

 - 每日自动创建新分区
     
</code></pre>
</li>
</ol>
<h2 id="复合主键"><a href="#复合主键" class="headerlink" title="复合主键"></a>复合主键</h2><blockquote>
</blockquote>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a><strong>其他函数</strong></h2><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a><strong>其他指令</strong></h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>create database db;</td>
<td>创建数据库</td>
</tr>
<tr>
<td><code>show databases;</code></td>
<td>列出数据库</td>
</tr>
<tr>
<td><code>use</code> db<code>;</code></td>
<td>切换到数据库</td>
</tr>
<tr>
<td><code>drop database</code> db<code>;</code></td>
<td>删除数据库</td>
</tr>
</tbody></table>
<h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a><strong>数据表</strong></h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>show tables;</code></td>
<td>列出当前数据库的表</td>
</tr>
<tr>
<td><code>show fields from</code> t<code>;</code></td>
<td>列出表的字段</td>
</tr>
<tr>
<td><code>desc</code> t<code>;</code></td>
<td>显示表结构</td>
</tr>
<tr>
<td><code>show create table t``;</code></td>
<td>显示创建表sql</td>
</tr>
<tr>
<td><code>truncate table t``;</code></td>
<td>删除表中的所有数据</td>
</tr>
<tr>
<td><code>drop table t``;</code></td>
<td>删除表</td>
</tr>
</tbody></table>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong>进程</strong></h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>kill</code> 进程号<code>;</code></td>
<td>杀死进程</td>
</tr>
<tr>
<td><code>show processlist;</code></td>
<td>列出进程</td>
</tr>
</tbody></table>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><strong>其他</strong></h3><blockquote>
<p>跳过行的偏移量并返回接下来的 n 行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT c1, c2 FROM t</span><br><span class="line">ORDER BY c1 </span><br><span class="line">LIMIT n OFFSET offset</span><br></pre></td></tr></table></figure>

<h2 id="CSV存储引擎的使用"><a href="#CSV存储引擎的使用" class="headerlink" title="CSV存储引擎的使用"></a><strong>CSV存储引擎的使用</strong></h2><p>使用场景：作为中间表</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>徐鑫</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/10/31/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/" title="mysql">http://example.com/2022/10/31/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/12/28/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/" rel="prev" title="前端基本内容"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">前端基本内容</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/10/20/javaweb/spring/" rel="next" title="spring"><span class="post-nav-text">spring</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 徐鑫</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script src="/js/markmap.js"></script></body></html>