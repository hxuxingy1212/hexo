<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="徐鑫"><meta name="copyright" content="徐鑫"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>JVM | 徐鑫的笔记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"徐鑫的笔记","version":"1.10.6","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="初始JVM 定义：java virtual Machine java程序的运行环境（java二进制字节码的运行环境）好处  一次编写，到处运行（jvm屏蔽了java代码和操作系统的差异） 自动内存管理，垃圾回收（最重要，c语言是没有的，需要程序员手动管理，容易造成内存泄漏） 数组下标越界检查（c语言，会覆盖其他部分的内存而不是抛异常，前者更严重）   常见的jvm jvm是一套规范，只要符合这套规">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/08/05/JVM/JVM/index.html">
<meta property="og:site_name" content="徐鑫的笔记">
<meta property="og:description" content="初始JVM 定义：java virtual Machine java程序的运行环境（java二进制字节码的运行环境）好处  一次编写，到处运行（jvm屏蔽了java代码和操作系统的差异） 自动内存管理，垃圾回收（最重要，c语言是没有的，需要程序员手动管理，容易造成内存泄漏） 数组下标越界检查（c语言，会覆盖其他部分的内存而不是抛异常，前者更严重）   常见的jvm jvm是一套规范，只要符合这套规">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220512233116228.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220512233805569.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220713212959876.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220713214422254.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220714003720569.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220718164728251.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220718164814326.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220718173101635.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720150147347.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720150754325.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720151007691.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720153953209.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720154302553.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720161213902.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720161840089.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720165150755.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220721172254593.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220722142732847.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220722143235835.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220722144005234.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220725142923128.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220725161623744.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220726161153283.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727163332706.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727163451368.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727163506964.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727163805434.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727164017707.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727164232682.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727164251197.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727164622673.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165014132.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165105944.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165620095.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165819421.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165956964.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170052203.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170111008.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170623468.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170752929.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170825185.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727172308630.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727172323441.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727172821946.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728155250306.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728155400364.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728155940787.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728155923536.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728160838675.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728160817007.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728163521477.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728163454476.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728164442556.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728164405696.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728165213010.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728165153568.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728165843690.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728165906682.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728171152614.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728171132935.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728171930029.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728172144342.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728172537845.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728172506834.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728173154742.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728172958363.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728173439549.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728173714430.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728173837362.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728174255057.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728174210450.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143308943.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143509759.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143818352.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143831642.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143856497.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729144034576.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729144137658.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729144858153.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729144925508.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729145322688.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729145347804.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729145414091.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729145302263.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729150047364.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220801172651812.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220801173205299.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220801173108680.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802092226748.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802092505054.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802093004132.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802100709406.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802101818902.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802102849510.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802103129532.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802104146595.png">
<meta property="article:published_time" content="2022-08-05T02:18:37.539Z">
<meta property="article:modified_time" content="2022-09-22T09:44:56.176Z">
<meta property="article:author" content="徐鑫">
<meta property="article:tag" content="java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hexo.xuxin.world/hexo/image-20220512233116228.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="徐鑫"><img width="96" loading="lazy" src="/images/touxiang2.jpg" alt="徐鑫"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">徐鑫</a></div><span class="site-name">徐鑫的笔记</span><sub class="site-subtitle"></sub><div class="site-description">记录每一天所学</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">30</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">14</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">12</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qun.qq.com/qqweb/qunpro/share?_wv=3&amp;_wwv=128&amp;appChannel=share&amp;inviteCode=28OEdR&amp;appChannel=share&amp;businessType=9&amp;from=246610&amp;biz=ka" title="QQ 频道 - 小云之家" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.yunyoujun.cn/img/about/white-qrcode-and-search.jpg" title="微信" target="_blank" style="color:#1AAD19"><span class="icon iconify" data-icon="ri:wechat-2-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:camera-fill"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8BJVM"><span class="toc-number">1.</span> <span class="toc-text">初始JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84jvm"><span class="toc-number">1.1.</span> <span class="toc-text">常见的jvm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">jvm结构图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%B1%A0%E6%AF%94%E8%BE%83"><span class="toc-number">2.5.1.</span> <span class="toc-text">三池比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E6%B1%A0"><span class="toc-number">2.5.2.</span> <span class="toc-text">串池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">判断回收对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.3.</span> <span class="toc-text">使用工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">判断根对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">5种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">终结器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-number">3.3.6.</span> <span class="toc-text">引用队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">复制算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">分代回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-number">3.6.1.</span> <span class="toc-text">串行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">3.6.2.</span> <span class="toc-text">吞吐量优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">3.6.3.</span> <span class="toc-text">响应时间优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.6.4.</span> <span class="toc-text">G1垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">G1垃圾回收流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E5%9B%9E%E6%94%B6%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">G1回收细节详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FullGC"><span class="toc-number">3.6.4.3.</span> <span class="toc-text">FullGC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B7%A8%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">3.6.4.4.</span> <span class="toc-text">新生代跨代回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Remark"><span class="toc-number">3.6.4.5.</span> <span class="toc-text">Remark</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D"><span class="toc-number">3.6.4.6.</span> <span class="toc-text">G1字符串去重</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.6.4.7.</span> <span class="toc-text">类卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6"><span class="toc-number">3.6.4.8.</span> <span class="toc-text">巨型对象回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">3.7.</span> <span class="toc-text">性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">3.7.1.</span> <span class="toc-text">查看虚拟机运行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E6%96%B9%E5%90%91"><span class="toc-number">3.7.2.</span> <span class="toc-text">调优方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E7%9B%AE%E6%A0%87"><span class="toc-number">3.7.3.</span> <span class="toc-text">调优目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E4%B8%8D%E5%8F%91%E7%94%9FGC"><span class="toc-number">3.7.4.</span> <span class="toc-text">尽量不发生GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%9A%84%E8%B0%83%E4%BC%98"><span class="toc-number">3.7.5.</span> <span class="toc-text">新生代的调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98"><span class="toc-number">3.7.6.</span> <span class="toc-text">老年代调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E8%B0%83%E4%BC%98"><span class="toc-number">3.7.6.1.</span> <span class="toc-text">案例调优</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">字节码指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">类文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8Ainit"><span class="toc-number">4.2.</span> <span class="toc-text">字节码解释init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">字节码解释输出语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7"><span class="toc-number">4.4.</span> <span class="toc-text">反编译工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E8%B5%8B%E5%80%BC"><span class="toc-number">4.5.</span> <span class="toc-text">从字节码角度分析赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90a"><span class="toc-number">4.6.</span> <span class="toc-text">从字节码角度分析a++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.7.</span> <span class="toc-text">从字节码角度分析流程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90x-0"><span class="toc-number">4.8.</span> <span class="toc-text">从字节码分析x&#x3D;0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90cinit"><span class="toc-number">4.9.</span> <span class="toc-text">从字节码分析cinit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90init"><span class="toc-number">4.10.</span> <span class="toc-text">从字节码分析init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">4.11.</span> <span class="toc-text">从字节码分析方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E5%A4%9A%E6%80%81"><span class="toc-number">4.12.</span> <span class="toc-text">从字节码分析多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.13.</span> <span class="toc-text">从字节码分析异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90syn"><span class="toc-number">4.14.</span> <span class="toc-text">从字节码分析syn</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">编译期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">默认构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">5.2.</span> <span class="toc-text">自动拆装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">5.3.</span> <span class="toc-text">范型擦除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach"><span class="toc-number">5.4.1.</span> <span class="toc-text">foreach</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swithc%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.5.</span> <span class="toc-text">swithc字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.6.</span> <span class="toc-text">switch枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">5.7.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-with-resource"><span class="toc-number">5.8.</span> <span class="toc-text">try-with-resource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.9.</span> <span class="toc-text">方法重写时的桥接方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.10.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">6.</span> <span class="toc-text">类加载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">6.1.</span> <span class="toc-text">加载阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="toc-number">6.2.</span> <span class="toc-text">链接阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">6.3.</span> <span class="toc-text">初始化阶段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">双亲委派模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">线程上下文类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.4.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">运行期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="toc-number">8.1.</span> <span class="toc-text">分层编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">8.2.</span> <span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-number">8.3.</span> <span class="toc-text">方法内联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E4%BC%98%E5%8C%96"><span class="toc-number">8.4.</span> <span class="toc-text">字段优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="toc-number">8.5.</span> <span class="toc-text">反射优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JMM%E7%AD%89"><span class="toc-number">9.</span> <span class="toc-text">JMM等</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/08/05/JVM/JVM/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="徐鑫"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="徐鑫的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JVM</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2022-08-05 10:18:37" itemprop="dateCreated datePublished" datetime="2022-08-05T10:18:37+08:00">2022-08-05</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2022-09-22 17:44:56" itemprop="dateModified" datetime="2022-09-22T17:44:56+08:00">2022-09-22</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Java/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Java</span></a></span> > <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Java/JVM/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">JVM</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">java</span></a><a class="tag-item" href="/tags/JVM/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">JVM</span></a></span></div><div class="post-author"><span class="author-name">徐鑫</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="初始JVM"><a href="#初始JVM" class="headerlink" title="初始JVM"></a><strong>初始JVM</strong></h1><blockquote>
<p><strong>定义：java virtual Machine java程序的运行环境（java二进制字节码的运行环境）</strong><br><strong>好处</strong></p>
<ul>
<li><strong>一次编写，到处运行（jvm屏蔽了java代码和操作系统的差异）</strong></li>
<li><strong>自动内存管理，垃圾回收（最重要，c语言是没有的，需要程序员手动管理，容易造成内存泄漏）</strong></li>
<li><strong>数组下标越界检查（c语言，会覆盖其他部分的内存而不是抛异常，前者更严重）</strong><img src="http://hexo.xuxin.world/hexo/image-20220512233116228.png" width="60%" loading="lazy"></li>
</ul>
</blockquote>
<h2 id="常见的jvm"><a href="#常见的jvm" class="headerlink" title="常见的jvm"></a><strong>常见的jvm</strong></h2><blockquote>
<p><strong>jvm是一套规范，只要符合这套规范，你可以自己实现，我们使用的hotspot，openJDK是可以自由使用且免费的</strong></p>
</blockquote>
<h2 id="jvm结构图"><a href="#jvm结构图" class="headerlink" title="jvm结构图"></a><strong>jvm结构图</strong></h2><blockquote>
<ul>
<li><strong>java程序编译成Class字节码文件时会进行一个编译优化</strong></li>
<li><strong>ClassLoader：类加载器，将字节码文件加载到jvm中去运行</strong></li>
<li><strong>MethodArea方法区：存放类</strong></li>
<li><strong>Heap堆：存放实例对象</strong></li>
<li><strong>JVMStacks，PC register程序计数器，NativeStacks本地方法栈：实例调用方法时会使用</strong></li>
<li><strong>Interpreter解释器：逐行解释java代码</strong></li>
<li><strong>JITCompiler即时编译器：会对热点代码优化</strong></li>
<li><strong>GC垃圾回收：回收堆中不需要的对象</strong></li>
<li><strong>本地方法接口：调用系统方法</strong><img src="http://hexo.xuxin.world/hexo/image-20220512233805569.png" width="80%" loading="lazy"></li>
</ul>
</blockquote>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a><strong>内存结构</strong></h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h2><blockquote>
<p><strong>定义</strong><br>Program Counter Register 程序计数器（寄存器）</p>
</blockquote>
<blockquote>
<p><strong>作用</strong><br>二进制字节码文件对应有很多条jvm指令，当一条指令执行时，程序计数器会记住下一条指令的地址，指令执行完后会再记住下一条的地址，解释器再到程序计数器里取再解释成机器码交给cpu执行<br><img src="http://hexo.xuxin.world/hexo/image-20220713212959876.png" alt="image-20220713212959876" loading="lazy"><br><strong>为什么用寄cpu里寄存器来当程序计数器？</strong><br>因为取地址这个操作是很频繁的，所以执行速度一定要快，寄存器是cpu最快的单元<br><strong>特点</strong></p>
<ul>
<li>是线程私有的（每个线程都有自己的程序计数器）</li>
<li>不会存在内存溢出（唯一一个部分不会存在，jvm规范规定的，厂商不需要再考虑）</li>
</ul>
</blockquote>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h2><blockquote>
<p><strong>定义</strong><br>Jaya Virtual Machine Stacks (Java 虚拟机栈）</p>
<ul>
<li>栈：线程运行需要的内存空间</li>
<li>栈帧：每个方法运行时需要的内存（参数，局部变量，返回的地址）</li>
<li>栈由栈帧组成，一个栈帧代表一次方法的调用•每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的內存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法<img src="http://hexo.xuxin.world/hexo/image-20220713214422254.png" width="50%" loading="lazy"></li>
</ul>
</blockquote>
<p><strong>问题辨析</strong></p>
<blockquote>
<ol>
<li><strong>垃圾回收是否涉及栈内存？</strong><br> 不涉及，因为一个方法调用结束后，方法内部产生的变量等内容会跟着方法一起出栈</li>
<li><strong>栈内存分配越大越好吗？</strong><br> 可以通过-Xss设置栈内存，默认是1Mb，并不是越大越好，反而会减少可创建的线程数量，只是方法可以被递归调用的次数变多而已</li>
<li><strong>方法内的局部变量是否线程安全？</strong><br> 一般情况是，因为局部变量是线程私有的，每个线程都会有自己的栈，线程调用方法时，局部变量是在自己的活动栈帧里，几个线程就有几个局部变量，互不干扰<br> 但是，如果这个局部变量作为返回值返回，那么其他线程也能访问了，需要判断这个变量是否逃离了方法的作用范围</li>
</ol>
</blockquote>
<p><strong>辨析String家族</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//线程安全，StringBuilder是局部变量，线程各自创建，互不影响</span><br><span class="line">public static void m1() &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(1);</span><br><span class="line">    sb.append(2);</span><br><span class="line">    sb.append(3);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程不安全，sb是引用类型，其他线程也能访问</span><br><span class="line">public static void m2(StringBuilder sb) &#123;</span><br><span class="line">    sb.append(1);</span><br><span class="line">    sb.append(2);</span><br><span class="line">    sb.append(3);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程安全，StringBuffer的方法会被synchronized修饰</span><br><span class="line">public static void m3(StringBuffer sb) &#123;</span><br><span class="line">    sb.append(1);</span><br><span class="line">    sb.append(2);</span><br><span class="line">    sb.append(3);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line">//不安全，作为结果返回，其他线程也会拿到这个变量</span><br><span class="line">public static StringBuilder m4() &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(1);</span><br><span class="line">    sb.append(2);</span><br><span class="line">    sb.append(3);</span><br><span class="line">    return sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>栈内存溢出</strong><br>异常：<strong>java.lang.StackOverflowError</strong></p>
<ul>
<li>栈帧过多（递归调用没有设立终止条件）</li>
<li>栈帧过大（一般不可能）<br>举例：当json转换时，如果俩个实体互相包含，那么会抛出这个栈溢出的异常，需要手动在实体上添加@JsonIgnore</li>
</ul>
</blockquote>
<p><strong>线程诊断</strong></p>
<blockquote>
<p><strong>cpu占用高</strong><br>#查看cpu使用情况，断定哪一个pid的进程占用高<br>top<br>#查看所有线程根据pid过滤的使用情况<br>ps H -eo pid,tid,%cpu I grep 32655<br>#可以查看进程里线程的执行情况，根据ps命令可以看到tid的信息，16进制转换后，找到对应线程，可以定位到具体的代码的行数<br>jstack pid<br><strong>长时间没有返回值</strong><br>可能发生了线程死锁<br>java -jar运行后会有pid<br>jstack pid<br>最底部会出现死锁的提示信息，可以查看多个线程的那一行代码出现问题</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h2><blockquote>
<p>本地方法栈：java调用本地方法时需要的内存空间<br>本地方法：不是由java代码编写的，被native修饰的，比如Object的clone，wait等</p>
</blockquote>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h2><blockquote>
<p><strong>定义</strong><br><strong>使用new创建的对象都会使用堆内存来存放</strong><br><strong>特点</strong></p>
<ul>
<li><strong>线程共享，堆中对象都需要考虑线程安全问题</strong></li>
<li><strong>有垃圾回收机制</strong></li>
</ul>
</blockquote>
<blockquote>
<p><strong>异常：java. lang. OutofMemoryError</strong><br><strong>参数：-Xmx：最大堆大小，-Xms：初始堆大小</strong></p>
</blockquote>
<p><strong>默认堆内存大小</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">除非在命令行上指定了初始堆大小和最大堆大小，否则它们将根据计算机上的内存量进行计算。</span><br><span class="line"></span><br><span class="line">最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一在32位JVM上，如果有4 GB或更多的物理内存，则默认的最大堆大小最多可以为1 GB。在64位JVM上，如果有128GB或更多的物理内存，则默认的最大堆大小最大为32 GB。</span><br><span class="line">在JVM初始化期间分配了一个较小的值，称为初始堆大小。此数量至少为8 MB，否则为物理内存的1/64，最大为1 GB。分配给年轻代的最大空间量是堆总大小的三分之一，即年轻代和老年代默认的比例是1:2</span><br><span class="line">您可以使用-Xms（初始堆大小）和-Xmx（最大堆大小）来指定初始堆大小和最大堆大小。如果你知道你的应用程序有多少堆需要工作做好，你可以设置-Xms和-Xmx相同的值。否则，JVM将使用初始堆大小开始，然后将增大Java堆，直到找到堆使用率和性能之间的平衡为止。</span><br></pre></td></tr></table></figure>

<p><strong>堆内存溢出诊断</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.jps 工具</span><br><span class="line">查看当前系统中有哪些 java 进程</span><br><span class="line">2.jmap 工具</span><br><span class="line">查看堆內存占用情况 jmap -heap 进程id</span><br><span class="line">3. jconsole 工具</span><br><span class="line">图形界面的，多功能的监测工具，可以连续监测</span><br><span class="line">4.可视化虚拟机，可以获取前多少的最大堆内存占用的对象找不来，并且可以生成快照分析</span><br><span class="line">jvisualym</span><br></pre></td></tr></table></figure>

<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h2><blockquote>
<p><strong>定义</strong></p>
<ul>
<li>是一个所有java线程共享的区域，存储了跟类的结构相关的信息</li>
<li>包括成员变量，方法数据，成员方法，构造器，类加载器以及运行时常量池</li>
<li>它从虚拟机启动时创建，逻辑上是堆的一部分，但是并不强制它的位置<br>异常：java. lang. OutofMemoryError<br>hotspot 1.8以前使用了永久代就是使用堆的一部分作为方法区，1.8以后引入元空间，使用的是本地内存（操作系统的内存）<img src="http://hexo.xuxin.world/hexo/image-20220714003720569.png" width="70%" loading="lazy"></li>
</ul>
</blockquote>
<blockquote>
<p><strong>内存溢出</strong></p>
<ul>
<li>1.8以前会导致永久代内存溢出，32位JVM的默认最大内存大小为64 MB，64位版本为82 MB</li>
<li>1.8之后会导致元空间內存溢出，默认是操作系统的内存，可以设置参数<br>元空间异常：java.lang. OutofMemoryError：Metaspace<br>参数：-XX: MaxMetaspacesize 最大内存，-XX:MetaspaceSize 初始内存<br>永久代异常：java.lang.OutofMemoryError: PermGen space<br>参数：-XX:MaxPermsize=8m，</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内存溢出场景</strong></p>
<ul>
<li>spring</li>
<li>mybatis<br>都使用了cglib动态代理，会在运行时创建类的字节码对象</li>
</ul>
</blockquote>
<h3 id="三池比较"><a href="#三池比较" class="headerlink" title="三池比较"></a><strong>三池比较</strong></h3><blockquote>
<p>定义</p>
<ul>
<li>Class常量池：每一个class文件都有一个常量池，常量池保存着class的常量信息：字面量和符号引用，编译时产生</li>
<li>运行时常量池：当该类被加载解析后生成，一个Class对应一个，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
<li>串池：就是在运行时保存字符串的池子，被放在堆中，而且全局唯一</li>
</ul>
</blockquote>
<h3 id="串池"><a href="#串池" class="headerlink" title="串池"></a><strong>串池</strong></h3><blockquote>
<p><strong>定义</strong></p>
<ul>
<li>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。</li>
<li>在JDK6.0中，StringTable的长度是固定的，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；</li>
<li>在JDK7.0中，StringTable的长度可以通过参数指定：</li>
<li>XX:StringTableSize=66666</li>
</ul>
</blockquote>
<p><strong>特性</strong></p>
<blockquote>
<ol>
<li>常量池中的字符串仅是符号，第一次用到时才变为对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是 StringBuilder (1.8)<br>“a”+”b”=&gt;new StringBuilder().append(“a”).apend(“b”).toString<br>会产生一个StringBuilder对象和一个String对象</li>
<li>字符串常量拼接的原理是编译期优化</li>
<li>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池<br>jdk8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回<br>jdk6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有复制一份再放入串池，会把串池中的对象返回</li>
</ol>
</blockquote>
<p><strong>位置</strong></p>
<blockquote>
<p>1.6:永久代的方法区中<br>1.7:堆中<br>1.8直接取消了永久代，改为本地内存的元空间</p>
</blockquote>
<p><strong>为什么要移出永久代</strong></p>
<blockquote>
<ul>
<li>在原来的永久代划分中，永久代需要存放类的元数据、静态变量和常量等。它的大小不容易确定，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等，-XX:MaxPermSize 指定太小很容易造成永久代内存溢出。</li>
<li>移除永久代是为融合HotSpotVM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</li>
<li>永久代会为GC带来不必要的复杂度，并且回收效率偏低</li>
</ul>
</blockquote>
<p><strong>StringTable的垃圾回收</strong></p>
<blockquote>
<p>StringTable也会垃圾回收</p>
</blockquote>
<p><strong>性能调优</strong></p>
<blockquote>
<ul>
<li>减少哈希表长度</li>
<li>合理使用串池</li>
</ul>
<p><strong>减少哈希表长度</strong><br>原理：StringTable是一个哈希表，String.intern每调用一次都会查找串池，查找效率和哈希表的长度有关，长度越长哈希冲突的概率越小<br>-XX：+PrintStringTableStatistics      打印StringTable信息<br>-XX: StringTableSize=1009                 设置串池大小<br><strong>合理使用串池</strong><br>原理：相同的字符串只能存一份，当大量字符串且其中有大量重复时，可以存进串池中，而不是堆内存，从而减少堆内存的消耗</p>
</blockquote>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a><strong>直接内存</strong></h2><blockquote>
<p>Direct Memory</p>
<ul>
<li>常见于 NIO 操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
<li>操作系统的内存</li>
</ul>
</blockquote>
<p><strong>使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DirectMemory &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024 * 1024);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(&quot;开始回收&quot;);</span><br><span class="line">        byteBuffer = null;</span><br><span class="line">        System.gc();//显式的拉圾回收，Full GC</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么读写快？</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220718164728251.png" width="50%"/ loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220718164814326.png" width="50%"/ loading="lazy">

<blockquote>
<p>直接内存，java代码和cpu都能直接访问，而不用从系统内存复制一份到java堆内存来让java代码可以访问</p>
</blockquote>
<p><strong>内存溢出</strong></p>
<blockquote>
<p>也会发生内存溢出情况，不过是基于操作系统的内存，较大</p>
</blockquote>
<p><strong>释放原理</strong></p>
<blockquote>
<p>java垃圾回收不管理直接内存，直接内存的释放需要主动调用unsafe. freeMemory(base)方法<br>借助了java中的虚引用机制，当虚引用对象被回收时，会触发定时任务，清理创建的直接内存<br>ByteBuffer 的实现类内部，使用了 cleaner（虚引用）来监测 ByteBuffer 对象，<br>一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleanqr 的 clean 方法调用 freeMemory 来释放直接内存</p>
</blockquote>
<p><strong>禁用显式垃圾回收对直接内存的影响</strong></p>
<blockquote>
<p>-XX:+DisableExplicitGc 关闭显式垃圾回收<br>System.gc();//显式的拉圾回收，Full GC<br>影响：会使直接内存长时间没法回收，造成内存溢出<br>解决：使用unsafe.freeMemory来手动释放内存</p>
</blockquote>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h1><h2 id="判断回收对象"><a href="#判断回收对象" class="headerlink" title="判断回收对象"></a><strong>判断回收对象</strong></h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h3><blockquote>
<p>描述：当一个对象被引用时计数加1，当一个对象取消引用计数减1，为0时回收<br>缺点：存在俩个对象互为引用时，则永远无法被回收<br><img src="http://hexo.xuxin.world/hexo/image-20220718173101635.png" width="50%" / loading="lazy"></p>
</blockquote>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h3><blockquote>
<p>根对象：不能被回收的对象<br>描述：堆中被根引用或间接引用的不会被垃圾回收，其余被回收</p>
</blockquote>
<h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a><strong>使用工具</strong></h3><blockquote>
<p>jps 查看进程id<br>jmap抓取程序，将其转储为二进制文件<br>dump转储，format=b二进制格式，live执行一次垃圾回收只保留存活的，file=1.bin文件名，21384进程id<br>jmap -dump: format=b,live,file=l.bin 21384</p>
</blockquote>
<h2 id="判断根对象"><a href="#判断根对象" class="headerlink" title="判断根对象"></a><strong>判断根对象</strong></h2><blockquote>
<p>SystemClass 系统对象<br>Thread    存活的线程对象<br>BusyMonitor 同步synchronized的对象<br>NativeStack 本地方法中被引用的对象<br>等等</p>
</blockquote>
<h2 id="5种引用"><a href="#5种引用" class="headerlink" title="5种引用"></a><strong>5种引用</strong></h2><blockquote>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
<li>终结器引用</li>
</ul>
</blockquote>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a><strong>强引用</strong></h3><blockquote>
<p>只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收，换句话说就是，只要强引用存在，JVM 垃圾回收器就永远都不会回收被引用的对象，即使内存不足，JVM 会抛出 OutOfMemoryError</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只要 obj 指向 Object 对象，那它就永远都不会被 JVM 回收</span><br><span class="line">Object obj = new Object();</span><br><span class="line">//将 obj 置为 null，可以切断引用链，这样 obj 就会被 JVM 回收</span><br><span class="line">obj = null;</span><br></pre></td></tr></table></figure>

<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a><strong>软引用</strong></h3><blockquote>
<p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象，即在内存足够时，JVM 不会回收软引用对象，但当内存不足时，软引用对象就会被回收，所以软引用对象通常用来描述一些非必要但仍有用的对象。</p>
</blockquote>
<p><strong>软引用的使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM参数 ： -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    //关联了引用队列，当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span><br><span class="line">    SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[1024 * 1024 * 4], queue);</span><br><span class="line">    System.out.println(ref.get());</span><br><span class="line">    list.add(ref);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从队列中获取无用的软引用对象，并从list中移出</span><br><span class="line">Reference&lt;? extends byte[]&gt; poll = queue.poll();//获取最先进入队列的元素，移出队列并返回</span><br><span class="line">while (poll != null) &#123;</span><br><span class="line">    list.remove(poll); //list中移出这个元素</span><br><span class="line">    poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (SoftReference&lt;byte[]&gt; reference : list) &#123;</span><br><span class="line">    System.out.println(reference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a><strong>弱引用</strong></h3><blockquote>
<p>弱引用是较软引用更第低一级的引用，只要发生垃圾回收，无论内存是否充足，JVM 都会回收掉弱引用对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h3><blockquote>
<p>虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，垃圾回收时，被引用对象回收，会自动将虚引用入队，由 Reference Handler 线程调用虚引用相关方法（例如释放直接内存）</p>
</blockquote>
<p><strong>直接内存原理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s =  new String(&quot;123&quot;);</span><br><span class="line">Cleaner cleaner = Cleaner.create(s,()-&gt;&#123;</span><br><span class="line">    System.out.println(&quot;回收了&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">s = null;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(&quot;gc结束&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出<br>gc结束<br>回收了</p>
</blockquote>
<p><strong>虚引用使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String s = new String(&quot;123&quot;);</span><br><span class="line">ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;String&gt; stringPhantomReference = new PhantomReference&lt;&gt;(s, queue);</span><br><span class="line">Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Reference&lt;? extends String&gt; poll = queue.poll();</span><br><span class="line">        if (poll != null) &#123;</span><br><span class="line">            System.out.println(&quot;abc&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">s = null;</span><br><span class="line">System.gc();</span><br><span class="line">System.out.println(&quot;gc结束&quot;);</span><br><span class="line">while (true) &#123;</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出<br>gc结束<br>abc</p>
</blockquote>
<h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a><strong>终结器</strong></h3><blockquote>
<p>只要重写了finalize方法，虚拟机自动创建终结器引用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程（优先级很低）通过终结器引用找到被引用对象并调用 finalize 方法，第二次 GC 时回收被引用对象<br>强烈不推荐，可能导致性能问题，死锁，挂起和其他问题行为”，并且因为“终结的时间无法预测，无法保证将调用终结器</p>
</blockquote>
<h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a><strong>引用队列</strong></h3><blockquote>
<p>目的：垃圾回收回收的是对象，而引用可以由引用队列来回收。<br>软引用和弱引用可以使用引用队列来回收引用，虚引用必须配合引用队列使用，终结器有自己的引用队列，无需编码。</p>
</blockquote>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a><strong>垃圾回收算法</strong></h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><strong>标记清除算法</strong></h3><blockquote>
<p>标记：标记哪些不是GcRoot引用的，需要被清除的<br>清楚：将起始结束地址放入空闲队列，如果有需要新的内存，再看看是否满足，满足就覆盖，不会清0操作<br>优点：速度快，没有额外处理<br>缺点：没有整理，空间不连续，容易出现内存碎片，大的内存需要时，还是会造成内存溢出<br><img src="http://hexo.xuxin.world/hexo/image-20220720150147347.png" width="50%" / loading="lazy"></p>
</blockquote>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a><strong>标记整理算法</strong></h3><blockquote>
<p>思路：和上一个一样<br>优点：没有碎片<br>缺点：速度慢，整理时，所有相关的地址都需要相应改变，工作量大，在存活较多时适合<br><img src="http://hexo.xuxin.world/hexo/image-20220720150754325.png" width="50%" / loading="lazy"></p>
</blockquote>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h3><blockquote>
<p>思路：先标记，然后将存活的放入to内存空间中，再清空from，再将to和from交换<br>优点：没有碎片<br>缺点：需要双倍的内存空间，适合存活较少时<br><img src="http://hexo.xuxin.world/hexo/image-20220720151007691.png" width="50%" / loading="lazy"></p>
</blockquote>
<h2 id="分代回收机制"><a href="#分代回收机制" class="headerlink" title="分代回收机制"></a><strong>分代回收机制</strong></h2><p><strong>分代垃圾回收的介绍</strong></p>
<blockquote>
<p>老年代：存放长时间使用的<br>新生代：需要频繁被回收的</p>
</blockquote>
<p><strong>结构</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220720153953209.png" width="80%" / loading="lazy">


<p><strong>流程</strong></p>
<blockquote>
<ul>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间(伊甸园)不足时，触发 minor gc，伊甸园和 from 存活的对象使用复制算法复制到to 中，存活的对象年龄加1并且交换 from和 to的指向</li>
<li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>当对象寿命超过國值时，会晋升至老年代，最大寿命是15 (4bit)</li>
<li>当有大对象，直接超过了新生代的大小，那么会直接到老年代，不会出发minor gc，如果新生代存不下了，会先minor gc，如果还存不下，会直接存到老年代。</li>
<li>幸存区空间满了，会触发minor gc，一部分晋升老年代，一部分移到to幸存区。</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 foll gc, STW的时间更长</li>
</ul>
</blockquote>
<p><strong>VM相关参数</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220720154302553.png" width="80%" / loading="lazy">

<p><strong>其他</strong></p>
<blockquote>
<p>当子线程出现内存溢出时，不会影响主线程的运行<br>当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行</p>
</blockquote>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a><strong>垃圾回收器</strong></h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a><strong>串行</strong></h3><blockquote>
<ul>
<li>单线程 </li>
<li>堆内存较小，适合个人电脑</li>
<li>开启串行垃圾回收器vm参数：-XX:+UseSerialGC = Serial+Serialold</li>
<li>Serial:新生代垃圾回收器，采用复制算法</li>
<li>Serialold:老年代垃圾回收器，采用标记整理算法</li>
</ul>
</blockquote>
<p><strong>流程</strong><br><img src="http://hexo.xuxin.world/hexo/image-20220720161213902.png" width="80%" / loading="lazy"></p>
<h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a><strong>吞吐量优先</strong></h3><blockquote>
<ul>
<li>多线程</li>
<li>堆内存较大，多核cpu</li>
<li>让单位时间内，STW的时间最短</li>
</ul>
</blockquote>
<p><strong>vm参数</strong></p>
<blockquote>
<ul>
<li>-XX:+UseParallelGC ~</li>
<li>-XX:+UseParalleloldGC<br>jdk8默认的,前一个是年轻代，采用复制算法，后一个是老年代，采用标记整理算法，只要开启一个，另一个也自动开启</li>
</ul>
<p><strong>其他配置参数，其中2，3冲突，只能存在一个</strong></p>
<ul>
<li>-XX:+UseAdaptiveSizePolicy 使用自适应大小策略，会调整新生代的伊甸园和幸存区的大小，也会调整整个堆的大小</li>
<li>-XX:GCTimeRatio=ratio  #吞吐量指标:1/(1+ratio)默认ratio为99,当一次垃圾回收没有达到这个指标，会调整堆大小来适应</li>
<li>-XX : MaxGCPauseMillis=ms #最大暂停毫秒数，默认200，当一次垃圾回收没有达到这个指标，会调整堆大小来适应</li>
<li>-XX:ParallelGCThreads=n  可以限制并行垃圾回收的线程数<img src="http://hexo.xuxin.world/hexo/image-20220720161840089.png" width="80%" / loading="lazy">
垃圾回收线程的个数和cpu一样（在cpu个数<某个值），所以垃圾回收时，cpu占用率达到100%，当然可以使用参数限制线程数。</li>
</ul>
</blockquote>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a><strong>响应时间优先</strong></h3><blockquote>
<ul>
<li>多线程</li>
<li>堆内存较大，多核cpu</li>
<li>尽可能让单词STW的时间最短</li>
</ul>
</blockquote>
<p><strong>vm参数</strong></p>
<blockquote>
<ul>
<li>-XX:+UseConcMarkSweepGC </li>
<li>-XX:+UseParNewGC - Serialold<br>第一个是并发标记清楚的老年代垃圾回收器，与之配合使用的是第二个基于复制算法的新生代垃圾回收器，第三个是第一个出现并发失败时的一个补救措施，让老年代单线程垃圾回收器来整理碎片</li>
<li>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads<br>第一个并行的线程数和前面一样，第二个是并发的线程数一般为第一个的1/4</li>
<li>-XX:CMSInitiatingOccupancyFraction=percent<br>执行CMS垃圾回收的内存占比，因为运行后产生的垃圾没法这次清理，所以需要预留一点内存给浮动垃圾，早期是60%</li>
<li>-XX:+CMSScavengeBeforeRemark<br>在重新标记前执行一次新生代垃圾回收，减轻重新标记的压力</li>
</ul>
</blockquote>
<p><strong>流程</strong><br><img src="http://hexo.xuxin.world/hexo/image-20220720165150755.png" width="80%" / loading="lazy"></p>
<blockquote>
<p><strong>初始标记</strong>：只会标记GC Roots，不会Tracing，速度很快<br><strong>并发标记</strong>：GC Roots Tracing标记整个可达对象的引用链<br><strong>重新标记</strong>：重新标记并发标记过程中用户的修改<br>重新标记阶段需要标记old区所有的存活对象，除了标记CG Root直接指向old区的引用链还要标记GC Root通过young区对象指向到old区对象的引用链，如果young区对象过多可以强制进行minor gc可以设置参数-XX:+CMSScavengeBeforeRemark 来减少扫描的对象<br><strong>注意</strong>：这个垃圾回收器没有整理碎片，如果内存不足时，产生并发失败，会让老年代单线程来整理，这是最大的缺点 </p>
</blockquote>
<h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a><strong>G1垃圾回收器</strong></h3><blockquote>
<p>定义：Garbage First<br>2004 论文发布<br>2009 JDK 6u14 体验<br>2012 JDK 714 官方支持<br>2017 JDK 9 默认</p>
</blockquote>
<p><strong>适用场景</strong></p>
<blockquote>
<ul>
<li>同时注重吞吐量(Throughput）和低延迟(Low latency)，默认的暂停目标是200 ms</li>
<li>超大堆內存，会将堆划分为多个大小相等的 Region</li>
<li>整体上是标记+整理算法，两个区域之间是复制算法</li>
</ul>
</blockquote>
<p><strong>相关JVM参数</strong></p>
<blockquote>
<ul>
<li>-XX:+UseG1GC  #jdk8还不是默认的，需要指定</li>
<li>-XX:G1HeapRegionSize=size  #region的大小划分</li>
<li>-XX:MaxGCPauseMillis=time  #默认暂停时间，默认是200ms</li>
</ul>
</blockquote>
<h4 id="G1垃圾回收流程"><a href="#G1垃圾回收流程" class="headerlink" title="G1垃圾回收流程"></a><strong>G1垃圾回收流程</strong></h4><blockquote>
<p>新生代——&gt;新生代+并发标记——&gt;混合收集(年轻代加老年代)<br><img src="http://hexo.xuxin.world/hexo/image-20220721172254593.png" width="30%" / loading="lazy"></p>
</blockquote>
<blockquote>
<p><strong>新生代</strong></p>
<ul>
<li>新生代垃圾回收：STW，同时在这个STW里会初始标记GC root</li>
<li>eden满，新生代垃圾回收，使用复制算法，复制到幸存区</li>
<li>幸存区满，垃圾回收,一部分会晋升老年代，一部分会用复制算法移动其他幸存区（to）</li>
</ul>
</blockquote>
<blockquote>
<p><strong>新生代+并发标记</strong></p>
<ul>
<li>新生代垃圾回收STW里会初始标记GC root</li>
<li>当老年代占总内存的一个阈值时，会做并发标记（不会STW)</li>
<li>xx: InitiatingHeapOccupancyPercent=percent （默认45%)并发标记阈值</li>
</ul>
</blockquote>
<blockquote>
<p><strong>混合收集</strong><br>对E，S，O全面回收</p>
<ul>
<li>新生代回收</li>
<li>最终标记（会STW)</li>
<li>拷贝存活 (会STW) 老年代会使用复制算法，有选择的将回收价值大的老年代回收，复制到其他老年代</li>
<li>XX:MaxGCPauseMillis=ms  最大暂停时间，默认200ms<br>为了满足这一个条件，所以会有选择的回收老年代最大价值的区域，所以叫G1</li>
</ul>
</blockquote>
<h4 id="G1回收细节详解"><a href="#G1回收细节详解" class="headerlink" title="G1回收细节详解"></a><strong>G1回收细节详解</strong></h4><p><strong>年轻代GC</strong></p>
<blockquote>
<p><strong>回收时机</strong><br>(1). 当Eden空间耗尽时,G1会启动一次年轻代垃圾回收过程<br>(2). 年轻代垃圾回收只会回收Eden区和Survivor区<br><strong>第一阶段，根扫描</strong></p>
<ul>
<li>会触发STW，同时在这个STW里会初始标记GC root</li>
<li>一定要考虑remembered Set,看是否有老年代中的对象引用了新生代对象</li>
<li>根引用连同RSet记录的外部引用作为扫描存活对象的入口</li>
</ul>
<p><strong>第二阶段，更新RSet</strong><br>当有老年代引用新生代时，标记这个对象所在的card为脏card，新生代region会有一个Remembered Set记录外部引用。减少了找GCroot的时间。当引用变更时，会被写屏障一个程序拦截，会放入一个脏卡更新队列中，让一个线程去异步更新RememberedSet。<br><strong>第三阶段，处理RSet</strong><br>识别被老年代对象指向的Eden中的对象,这些被指向的Eden中的对象被认为是存活的对象<br><strong>第四阶段，复制对象</strong><br>此阶段,对象树被遍历,Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段,Survivor区内存段中存活的对象如果年龄未达阈值,年龄会加1,达到阀值会被会被复制到old区中空的内存分段。&gt;如果Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间<br><strong>第五阶段，处理引用</strong><br>处理Soft,Weak, Phantom, Final, JNI Weak等引用。</p>
</blockquote>
<p><strong>新生代+并发标记过程</strong></p>
<blockquote>
<ul>
<li>一、初始标记阶段:GCroot初始标记，在年轻代回收时就做了</li>
<li>二、并发标记(Concurrent Marking):在整个堆中进行并发标记(和应用程序并发执行)。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时,并发标记过程中,会计算每个区域的对象活性(区域中存活对象的比例)。</li>
<li>四、再次标记(Remark):由于应用程序持续进行,需要修正上一次的标记结果。是STW的。</li>
<li>五、独占清理(cleanup,STW):计算各个区域的存活对象和GC回收比例,并进行排序,识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)</li>
<li>六、并发清理阶段:识别并清理完全空闲的区域</li>
</ul>
</blockquote>
<p><strong>混合回收 Mixed GC</strong></p>
<blockquote>
<p>先新生代回收，最终标记（会STW），老年代会使用复制算法，有选择的将回收价值大的老年代回收，复制到其他老年代，其中最终标记和拷贝存活会STW<br><strong>注意</strong>：会优先回收价值大的区域，以满足-XX:MaxGCPauseMillis=ms  最大暂停时间，默认200ms</p>
</blockquote>
<p><strong>G1的可选过程四：Full GC</strong></p>
<blockquote>
<p>G1会停止应用程序的执行(Stop-The-World) ，使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。<br><strong>导致G1Full GC的原因可能有</strong></p>
<ul>
<li>回收的时候没有足够的to-space来存放晋升的对象</li>
<li>处理过程没完成空间就耗尽了</li>
<li>当垃圾产生速度快于回收速度时会触发fullGC此时会转到单线程做较长的STW</li>
</ul>
</blockquote>
<h4 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a><strong>FullGC</strong></h4><blockquote>
<p>SerialGC</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc<br>ParallelGC</li>
<li>新生代内存不足发生的垃圾收集 - minor gC</li>
<li>老年代内存不足发生的垃圾收集 - full ge<br>CMS</li>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足不叫，并发失败以后才叫，转到单线程做较长的STW<br>G1</li>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存达到一定百分比时还不叫，当垃圾产生速度快于回收速度时会触发fullGC做较长的STW</li>
</ul>
</blockquote>
<h4 id="新生代跨代回收"><a href="#新生代跨代回收" class="headerlink" title="新生代跨代回收"></a><strong>新生代跨代回收</strong></h4><blockquote>
<p>新生代回收需要标记Gcroot对象，当有新生代对象被老年代引用时，需要遍历老年代，此时速度很慢，将老年代按大小拆分成固定大小的card，当有老年代引用新生代时，标记这个对象所在的card为脏card，新生代region会有一个Remembered Set记录外部引用。减少了找GCroot的时间。当引用变更时，会被写屏障一个程序拦截，会放入一个脏卡更新队列中，让一个线程去异步更新RememberedSet。<br><img src="http://hexo.xuxin.world/hexo/image-20220722142732847.png" width="50%" / loading="lazy"></p>
</blockquote>
<h4 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a><strong>Remark</strong></h4><blockquote>
<p>并发标记阶段用户线程运行，当有引用变更时，会被写屏障拦截，放入一个队列中，并将其标记为灰色，表示正在处理，当并发阶段结束后，进入重新标记阶段，会STW，将队列中的对象取出，并检查，防止错误的回收<br><img src="http://hexo.xuxin.world/hexo/image-20220722143235835.png" width="50%" / loading="lazy"></p>
</blockquote>
<h4 id="G1字符串去重"><a href="#G1字符串去重" class="headerlink" title="G1字符串去重"></a><strong>G1字符串去重</strong></h4><blockquote>
<p>jdk8u20<br><img src="http://hexo.xuxin.world/hexo/image-20220722144005234.png" width="50%" / loading="lazy"><br>UsestringDeduplication（bool）：开启 String 去重，默认是不开启的，需要手动开启。<br>Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息。</p>
</blockquote>
<p><strong>String中的char[] 如果相同只会存在一个</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;abc&quot;);</span><br><span class="line">String s2 = new String(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Field value1 = s1.getClass().getDeclaredField(&quot;value&quot;);</span><br><span class="line">    Field value2 = s2.getClass().getDeclaredField(&quot;value&quot;);</span><br><span class="line">    value1.setAccessible(true);</span><br><span class="line">    value2.setAccessible(true);</span><br><span class="line">    char[] o1 = (char[]) value1.get(s1);</span><br><span class="line">    char[] o2 = (char[]) value2.get(s2);</span><br><span class="line"></span><br><span class="line">    o1[0] = &#x27;c&#x27;;</span><br><span class="line">    System.out.println(o2[0]);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a><strong>类卸载</strong></h4><blockquote>
<p>Jdk8u40<br>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类<br>-xx:+ClassUnloadingwithConcurrentMark 默认启用</p>
</blockquote>
<h4 id="巨型对象回收"><a href="#巨型对象回收" class="headerlink" title="巨型对象回收"></a><strong>巨型对象回收</strong></h4><ul>
<li>—个对象大于 region 的一半时，称之为巨型对象</li>
<li>G1 不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1 会跟踪老年代所有 incomig引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><img src="http://hexo.xuxin.world/hexo/image-20220725142923128.png" alt="image-20220725142923128" loading="lazy"></p>
<p><strong>JDK9 并发标记起始时间的调整</strong></p>
<ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li>
<li>JDK 9 之前需要使用 -xx: InitiatingHeapOccupancyPercent</li>
<li>JDK 9 可以动态调整</li>
<li><ul>
<li>-xx:InitiatingHeapoccupancyPercent 用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的空档空间1</li>
</ul>
</li>
</ul>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a><strong>性能调优</strong></h2><h3 id="查看虚拟机运行参数"><a href="#查看虚拟机运行参数" class="headerlink" title="查看虚拟机运行参数"></a><strong>查看虚拟机运行参数</strong></h3><blockquote>
<p>查看本地jdk默认参数<br>/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java -XX:+PrintFlagsFinal -version / findstr “Gc”</p>
</blockquote>
<blockquote>
<p>查看官方文档虚拟机参数<br><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#overview-of-java-options">https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#overview-of-java-options</a></p>
</blockquote>
<h3 id="调优方向"><a href="#调优方向" class="headerlink" title="调优方向"></a><strong>调优方向</strong></h3><ul>
<li><strong>内存</strong></li>
<li><strong>锁竞争</strong></li>
<li><strong>cpu 占用</strong></li>
<li><strong>io</strong></li>
</ul>
<h3 id="调优目标"><a href="#调优目标" class="headerlink" title="调优目标"></a><strong>调优目标</strong></h3><blockquote>
<p>【低延迟】还是【高吞吐量】，选择合适的回收器</p>
<ul>
<li>CMS, G1, ZGC</li>
<li>ParallelGC(高吞吐量)</li>
<li>Zing（不是hotspot）</li>
</ul>
</blockquote>
<h3 id="尽量不发生GC"><a href="#尽量不发生GC" class="headerlink" title="尽量不发生GC"></a><strong>尽量不发生GC</strong></h3><blockquote>
<p><strong>数据是不是太多？</strong></p>
<ul>
<li>resultSet = statement.executeQuery(“seleet * from 大表 limit n”) 使用limit</li>
</ul>
<p><strong>数据表示是否太臃肿？</strong></p>
<ul>
<li>对象图  查需要的，不要全部查出来</li>
<li>对象大小 16 Integer 24 int 4，使用小类型</li>
</ul>
<p><strong>是否存在内存泄漏？</strong></p>
<ul>
<li>static Map map …    不要存在那种一直存在(强引用)并且不断添加元素，从不回收的对象</li>
<li>软，弱                  使用软，弱引用，使对象可以回收</li>
<li>第三方缓存实现            缓存使用第三方缓存不要自己new一个map</li>
</ul>
</blockquote>
<h3 id="新生代的调优"><a href="#新生代的调优" class="headerlink" title="新生代的调优"></a><strong>新生代的调优</strong></h3><blockquote>
<p>新生代速度远小于老年代，所以应该先从老年代开始</p>
<ul>
<li>所有的 new 操作的内存分配非常廉价<br>TLAB thread-local allocation buffer（创建对象会在线程eden的线程缓存区中创建）</li>
<li>死亡对象的回收代价是零</li>
<li>大部分对象用过即死</li>
<li>Minor GC 的时间远远低于 Full Gc</li>
</ul>
</blockquote>
<blockquote>
<p><strong>一、-Xmn 设置新生代内存大小</strong><br>这个值最好设置成（并发量  *（一次请求到响应）的数据<br>因为一次请求到响应的数据都是用过即死，这样设置会较少触发minorGC<br><strong>二、幸存区调优</strong></p>
<ol>
<li>幸存区大到能保留【当前活跃对象+需要晋升对象】<br>因为幸存区太小，jvm会动态调整晋升阈值，使得那些本来要被回收的晋升到老年代了</li>
<li>晋升阈值配置得当，让长时间存活对象尽快晋升</li>
</ol>
<p>-XX:MaxTenuringThreshold=threshold   晋升阈值<br>-XX:+PrintTenuringDistribution             打印各年龄的内存占用大小<br><img src="http://hexo.xuxin.world/hexo/image-20220725161623744.png" width="50%" / loading="lazy"></p>
</blockquote>
<h3 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a><strong>老年代调优</strong></h3><blockquote>
<p>以CMS 为例</p>
<ul>
<li>CMS 的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有 Full Gc 那么已经…，否则先尝试调优新生代</li>
<li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4~1/3</li>
<li>XX:CMSInitiatingOccupancyFraction=percent 老年代垃圾占内存比例，达到时做垃圾回收</li>
</ul>
<p>1.cpu可以的话，极端情况下可以设置为0，只要有垃圾就开启回收，使得没有浮动垃圾，不会做fullGc，但对cpu要求较高，需要始终有一个线程来做垃圾回收工作<br>2.一般设置成70%左右</p>
</blockquote>
<h4 id="案例调优"><a href="#案例调优" class="headerlink" title="案例调优"></a><strong>案例调优</strong></h4><blockquote>
<ul>
<li>案例1 Full GC 和 Minor GC频繁</li>
<li>案例2请求高峰期发生 Full GC，单次暂停时间特别长 (CMS)</li>
<li>案例;老年代充裕情况下，发生 Full GC (1.7)</li>
</ul>
</blockquote>
<p><strong>案例1</strong></p>
<blockquote>
<p>分析原因，是新生代空间不足，导致幸存区占满，然后jvm动态调整晋升阈值，使得老年代存放许多临时的对象，老年代占满后又触发fullGc。<br>解决：增加新生代空间大小，加大晋升阈值</p>
</blockquote>
<p><strong>案例2</strong></p>
<blockquote>
<p>初始标记和并发标记时间是较短的，重新标记时间较长，因为重新标记需要对老年代扫描而且也会对新生代开始扫描，先对垃圾回收器的时间阶段统计出各阶段的时间，发现重新标记确实时间较长<br>-XX:+CMSScavengeBeforeRemark可以开启这个参数，使得重新标记前做一次新生代垃圾回收，使得重新标记的对象较少。</p>
</blockquote>
<p><strong>案例3</strong></p>
<blockquote>
<p>jdk1.7方法区是永久代放在堆里，而1.8是元空间使用操作系统的内存，1.7方法区内存不足也会造成fullGc，增大永久代的内存空间</p>
</blockquote>
<p><strong>曾经出现的内存泄露问题</strong></p>
<blockquote>
<p>做安卓app时定义了一个static List 不断 存放添加进来的地图点信息。导致内存泄漏，app强退。<br>业务需求：添加时判断是否重复添加或者错误信息，并且将所有采集的数据显示在地图上。<br>解决：将业务判断等放在后端处理，调接口传数据就行，并且只展示当次采集的数据。</p>
</blockquote>
<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a><strong>字节码指令</strong></h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a><strong>类文件结构</strong></h2><blockquote>
<p><strong>编译成字节码文件</strong><br>Javac -parameters -d . Hellowworld.java </p>
</blockquote>
<p><strong>JVM规范，类文件结构</strong></p>
<blockquote>
<p>包含了java版本信息，常量池信息，类信息（修饰符，类名，父类名），接口信息，变量信息，方法信息（init，main）</p>
</blockquote>
<blockquote>
<pre><code>   u4                    magic;                  //魔术，4字节，cafebabe，表示它是否是class类型文件
   u2                    minor_version;          //版本，4-7字节，00000034，16进制为52表示java8，53表示java9 
   u2                    major_version;     
   u2                    constant_pool_count；   //常量池长度，8-9字节，0023(35)表示常量池有#1~#34项，#0项不计入
   cpinfo                 constant_pool[constant_pool_count-1]；
   u2                    access_flags;            //访问标识，public/private等
   u2                    this class；             //在常量池中找本类全限定名
   u2                    super_class；            //在常量池中找父类全限定名
   u2                    interfaces_count；      //接口数量
   u2                    interfaces[interfaces_count〕;
   u2                    field info                //Field类型
   u2                    fields_count；            //Field数量
   u2                    fields [fields_count ]；
   u2                    methods count;          //方法数量
  method info            methods Imethods _count];//方法信息：方法修饰类型，常量池中的名称等
   u2                    attributes_count;       //附加数量
   attribute info         attributes[attributes_count]；//附加属性信息
</code></pre>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a> 官网java8虚拟机规范</p>
</blockquote>
<h2 id="字节码解释init"><a href="#字节码解释init" class="headerlink" title="字节码解释init"></a><strong>字节码解释init</strong></h2><blockquote>
<p>2a b7 00 01 b1<br>this.init();//init=代表构造方法</p>
<ol>
<li>2a:aload_0,即this</li>
<li>b7:invokespecial预备调用构造方法</li>
<li>00 01:引用常量池中#1项，即【Method java/lang/Object.“<init>”:()V】</li>
<li>b1:表示返回</li>
</ol>
</blockquote>
<h2 id="字节码解释输出语句"><a href="#字节码解释输出语句" class="headerlink" title="字节码解释输出语句"></a><strong>字节码解释输出语句</strong></h2><blockquote>
<p>b2 00 02 12 03 b6 00 04 b1<br>System.out  “hello world”  .println(String)V</p>
<ol>
<li>b2:getstatic 加载静态变量</li>
<li>00 02:引用常量池中的#2项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</li>
<li>12:ldc加载常数</li>
<li>03：引用常量池中#3项，即【String hello world】</li>
<li>b6:invokevirtual 预备调用成员方法</li>
<li>00 04:引用常量池中#4项，即【Method java/io/PrintStream.printLn:(Ljava/lang/String;)V】</li>
<li>b1:表示返回</li>
</ol>
<p><strong>注意</strong>：字节码指令中顺序是先方法名，参数，然后调用方法</p>
</blockquote>
<h2 id="反编译工具"><a href="#反编译工具" class="headerlink" title="反编译工具"></a><strong>反编译工具</strong></h2><blockquote>
<p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件<br>javap -v Hellolorld.class<br>-v：输出类文件的详细信息</p>
</blockquote>
<h2 id="从字节码角度分析赋值"><a href="#从字节码角度分析赋值" class="headerlink" title="从字节码角度分析赋值"></a><strong>从字节码角度分析赋值</strong></h2><blockquote>
<ul>
<li>字节码中常量池放入运行时常量池（short最大值以下直接在Code中，不进入常量池）</li>
<li>字节码的Code方法加载入方法区</li>
<li>main 线程开始运行，分配栈帧内存（局部变量表，最大操作数栈）<img src="http://hexo.xuxin.world/hexo/image-20220726161153283.png" width="50%" / loading="lazy"></li>
</ul>
</blockquote>
<p><strong>bipush 10</strong></p>
<blockquote>
<ul>
<li>将一个 byte 压入操作数栈（其长度会补齐4个字节），类似的指令还有</li>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐4个字节）</li>
<li>lde 将一个 int 压入操作数栈</li>
<li>Idc2w将一个 long 压入操作数栈（分两次压入，因为long 是8个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池<img src="http://hexo.xuxin.world/hexo/image-20220727163332706.png" width="50%" / loading="lazy"></li>
</ul>
</blockquote>
<p><strong>Istore_1</strong></p>
<blockquote>
<p>将操作数栈顶数据弹出，存入局部变量表的 slot<br><img src="http://hexo.xuxin.world/hexo/image-20220727163451368.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220727163506964.png" width="50%" / loading="lazy"></p>
</blockquote>
<p><strong>Idc #3</strong></p>
<blockquote>
<p>从常量池加载#3数据到操作数栈<br>注意 Short.MAX_VALUE 是32767，所以32768： -Short.MAX_VALUE+1实际是在编译期间计算好的<br><img src="http://hexo.xuxin.world/hexo/image-20220727163805434.png" width="50%" / loading="lazy"></p>
</blockquote>
<p><strong>iload_1</strong></p>
<blockquote>
<p>将临时变量表中数据放入操作数栈中<br><img src="http://hexo.xuxin.world/hexo/image-20220727164017707.png" width="50%" / loading="lazy"></p>
</blockquote>
<p><strong>iadd</strong></p>
<blockquote>
<p>会将操作数栈的俩个值弹出，计算，将结果放入操作数栈中<br><img src="http://hexo.xuxin.world/hexo/image-20220727164232682.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220727164251197.png" width="50%" / loading="lazy"></p>
</blockquote>
<p><strong>getstatic #4</strong></p>
<blockquote>
<p>通过常量池找到堆中的对象，将对象的引用放入操作数栈中<br><img src="http://hexo.xuxin.world/hexo/image-20220727164622673.png" width="50%" / loading="lazy"></p>
</blockquote>
<p><strong>invokevirtual #5</strong></p>
<blockquote>
<ul>
<li>找到常量池#5 项</li>
<li>定位到方法区 java/io/PrintStream.printin：（I)V 方法</li>
<li>生成新的栈帧（分配 locals、 stack等）</li>
<li>传递参数，执行新栈帧中的字节码<img src="http://hexo.xuxin.world/hexo/image-20220727165014132.png" width="50%" / loading="lazy"></li>
<li>执行完毕，弹出栈帧</li>
<li>清除 main 操作数栈内容<img src="http://hexo.xuxin.world/hexo/image-20220727165105944.png" width="50%" / loading="lazy"></li>
</ul>
</blockquote>
<p><strong>Teturn</strong></p>
<blockquote>
<ul>
<li>完成 main 方法调用，弹出 main 栈帧</li>
<li>程序结束</li>
</ul>
</blockquote>
<h2 id="从字节码角度分析a"><a href="#从字节码角度分析a" class="headerlink" title="从字节码角度分析a++"></a><strong>从字节码角度分析a++</strong></h2><blockquote>
<ul>
<li>注意 iinc 指令是直接在局部变量 slot 上进行运算</li>
<li>a++和++a 的区别是先执行 iload 还是先执行 inc<img src="http://hexo.xuxin.world/hexo/image-20220727165620095.png" width="50%" / loading="lazy"></li>
</ul>
</blockquote>
<blockquote>
<p><strong>a++</strong><br><img src="http://hexo.xuxin.world/hexo/image-20220727165819421.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220727165956964.png" width="50%" / loading="lazy"></p>
</blockquote>
<blockquote>
<p><strong>++a</strong><br><img src="http://hexo.xuxin.world/hexo/image-20220727170052203.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220727170111008.png" width="50%" / loading="lazy"></p>
</blockquote>
<h2 id="从字节码角度分析流程控制"><a href="#从字节码角度分析流程控制" class="headerlink" title="从字节码角度分析流程控制"></a><strong>从字节码角度分析流程控制</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220727170623468.png" width="50%" / loading="lazy">
</blockquote>
<blockquote>
<ul>
<li>byte， short，char 都会按 int 比较，因为操作数栈都是4 字节</li>
<li>而long等类型则先lcmp，再ifne</li>
<li>根据比较结果用goto 来进行跳转到指定行号的字节码</li>
</ul>
</blockquote>
<p>源码</p>
<blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220727170752929.png" width="30%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220727170825185.png" width="30%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220727172308630.png" width="30%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220727172323441.png" width="30%" / loading="lazy">
</blockquote>
<h2 id="从字节码分析x-0"><a href="#从字节码分析x-0" class="headerlink" title="从字节码分析x=0"></a><strong>从字节码分析x=0</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220727172821946.png" width="30%" / loading="lazy">
解释：i++，先加载到操作数栈为0，再局部变量表++为1，然后执行赋值，此时将操作数栈的0给局部变量表的x（1）
</blockquote>
<h2 id="从字节码分析cinit"><a href="#从字节码分析cinit" class="headerlink" title="从字节码分析cinit"></a><strong>从字节码分析cinit</strong></h2><blockquote>
<p>字节码指令将所有静态会被合并成一个cinit方法，从上至下顺序cinit()V会在类加载的初始化阶段被调用<br><img src="http://hexo.xuxin.world/hexo/image-20220728155250306.png" width="30%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220728155400364.png" width="30%" / loading="lazy"></p>
</blockquote>
<h2 id="从字节码分析init"><a href="#从字节码分析init" class="headerlink" title="从字节码分析init"></a><strong>从字节码分析init</strong></h2><blockquote>
<p>编译器会按从上至下的顺序，收集所有代码块和成员变量赋值的代码，形成新的构造方法，但原始构造<br>方法内的代码总是在最后</p>
</blockquote>
<blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220728155940787.png" width="30%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220728155923536.png" width="30%" / loading="lazy">
</blockquote>
<h2 id="从字节码分析方法调用"><a href="#从字节码分析方法调用" class="headerlink" title="从字节码分析方法调用"></a><strong>从字节码分析方法调用</strong></h2><blockquote>
<p>init，private和static都是确定的，在编译阶段就能被确定，直接就能找到方法的地址，而public可能被重写，所以动态绑定，运行期间确定，需要查找多次<br>new 在堆中开辟一块空间给对象，将对象的引用放入操作数栈<br>dup 复制一份最上面的在操作数栈<br>使用实例对象调用静态方法会产生不必要的指令，aload_1和pop，因为静态方法的调用不需要实例<br><img src="http://hexo.xuxin.world/hexo/image-20220728160838675.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220728160817007.png" width="50%" / loading="lazy"></p>
</blockquote>
<h2 id="从字节码分析多态"><a href="#从字节码分析多态" class="headerlink" title="从字节码分析多态"></a><strong>从字节码分析多态</strong></h2><blockquote>
<p>当执行 invokevirtual 指令时</p>
<ul>
<li>先通过栈帧中的对象引用找到对象</li>
<li>分析对象头，找到对象的实际 Class</li>
<li>Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查表得到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
</blockquote>
<h2 id="从字节码分析异常处理"><a href="#从字节码分析异常处理" class="headerlink" title="从字节码分析异常处理"></a><strong>从字节码分析异常处理</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220728163521477.png" width="50%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220728163454476.png" width="50%" / loading="lazy">
可以看到多出来一个 Exception table 的结构，[from,to）是前闭后开的检测范围，一旦这个范围内的字节码
执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置
</blockquote>
<blockquote>
<p><strong>finally</strong><br>字节码指令中会分成3份，try，catch和发生其他异常，每一份都会在结尾加上finally，此时异常表中会额外多出一份其他异常，监听try和catch，当发生其他异常时会走第三份字节码指令。<br><img src="http://hexo.xuxin.world/hexo/image-20220728164442556.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220728164405696.png" width="50%" / loading="lazy"></p>
</blockquote>
<blockquote>
<p><strong>finally中return</strong><br><img src="http://hexo.xuxin.world/hexo/image-20220728165213010.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220728165153568.png" width="50%" / loading="lazy"><br>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准<br>finally中return会吞掉throw，即使try中有异常也不会报错，很危险⚠️</p>
</blockquote>
<blockquote>
<p><strong>解读istore_0</strong><br><img src="http://hexo.xuxin.world/hexo/image-20220728165843690.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220728165906682.png" width="50%" / loading="lazy"><br>return后面有值会将返回值暂存新的槽位固定返回值，最后再弹出，而finally的语句不影响这个新的槽位</p>
</blockquote>
<h2 id="从字节码分析syn"><a href="#从字节码分析syn" class="headerlink" title="从字节码分析syn"></a><strong>从字节码分析syn</strong></h2><blockquote>
<p>为什么synchronized代码块中出现了异常，会解锁？<br>利用了异常表，会监听正常流程，以及解锁过程异常也会重复执行解锁<br>方法级别的 synchronized 不会在字节码指令中有所体现<br><img src="http://hexo.xuxin.world/hexo/image-20220728171152614.png" width="50%" / loading="lazy"><br><img src="http://hexo.xuxin.world/hexo/image-20220728171132935.png" width="50%" / loading="lazy"></p>
</blockquote>
<h1 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a><strong>编译期处理</strong></h1><blockquote>
<p>所谓的 语法糖，其实就是指 java 编译器把*.java 源码编译为*.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）<br>注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件jclasslib 等工具。另外，编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的java 源码，切记。</p>
</blockquote>
<h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a><strong>默认构造器</strong></h2><img src="http://hexo.xuxin.world/hexo/image-20220728171930029.png" width="80%" / loading="lazy">

<h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a><strong>自动拆装箱</strong></h2><img src="http://hexo.xuxin.world/hexo/image-20220728172144342.png" width="80%" / loading="lazy">

<h2 id="范型擦除"><a href="#范型擦除" class="headerlink" title="范型擦除"></a><strong>范型擦除</strong></h2><img src="http://hexo.xuxin.world/hexo/image-20220728172537845.png" width="80%" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728172506834.png" width="80%" / loading="lazy">

<blockquote>
<p>注意：擦除的是字节码上（code）的泛型信息，可以看到 LocalVariableType Table 局部变量类型表仍然保留了方法参数泛型的信息</p>
</blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220728173154742.png" width="80%" / loading="lazy">

<p><strong>获取范型的信息</strong></p>
<p>只能获取方法的范型参数和返回值的范型信息</p>
<img src="http://hexo.xuxin.world/hexo/image-20220728172958363.png" width="80%" / loading="lazy">

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a><strong>可变参数</strong></h2><img src="http://hexo.xuxin.world/hexo/image-20220728173439549.png" width="80%" / loading="lazy">

<blockquote>
<p><strong>注意</strong><br>如果调用了 foo() 则等价代码为 Too(new String[]{})，创建了一个空的数组，而不会传递 nul1 进去</p>
</blockquote>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a><strong>foreach</strong></h3><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220728173714430.png" width="70%" / loading="lazy">
</blockquote>
<p>集合的优化</p>
<blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220728173837362.png" width="70%" / loading="lazy">
注意
foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器 (Iterator)
</blockquote>
<h2 id="swithc字符串"><a href="#swithc字符串" class="headerlink" title="swithc字符串"></a><strong>swithc字符串</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220728174255057.png" width="50%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220728174210450.png" width="30%" / loading="lazy">
</blockquote>
<h2 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a><strong>switch枚举</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220729143308943.png" width="30%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220729143509759.png" width="30%" / loading="lazy">
</blockquote>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a><strong>枚举类</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220729143818352.png" width="30%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220729143831642.png" width="30%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220729143856497.png" width="30%" / loading="lazy">
</blockquote>
<h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a><strong>try-with-resource</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220729144034576.png" width="50%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220729144137658.png" width="50%" / loading="lazy">
</blockquote>
<h2 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a><strong>方法重写时的桥接方法</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220729144858153.png" width="50%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220729144925508.png" width="50%" / loading="lazy">
</blockquote>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><strong>匿名内部类</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220729145322688.png" width="50%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220729145347804.png" width="50%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220729145414091.png" width="50%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220729145302263.png" width="50%" / loading="lazy">
</blockquote>
<h1 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a><strong>类加载阶段</strong></h1><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a><strong>加载阶段</strong></h2><blockquote>
<ul>
<li>将类的字节码载入方法区中，內部采用 C++ 的 instanceKlass 描述java 类，它的重要 field 有：</li>
<li>java_miror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>super 即父类</li>
<li>fields 即成员变量</li>
<li>methods 即方法</li>
<li>constants 即常量池</li>
<li>class_loader 即类加载器</li>
<li>vtable 虚方法表</li>
<li>itable 接口方法表</li>
<li>如果这个类还有父类没有加载，先加载父类</li>
<li>加载和链接可能是交替运行的<img src="http://hexo.xuxin.world/hexo/image-20220729150047364.png" width="80%" / loading="lazy"></li>
</ul>
</blockquote>
<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a><strong>链接阶段</strong></h2><blockquote>
<p>验证：验证类是否符合JVM规范，安全性检查<br>准备：为 static 变量分配空间，设置默认值</p>
<ul>
<li>static 变量在JDK 7 之前存储于 instanceKlass 末尾，从JDK 7开始，存储于_java_ mirror 末尾</li>
<li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成,「赋值在初始化阶段（cinit）完成</li>
<li>如果 static 变量是 final 的基本类型和String的“ ”，那么编译阶段值就确定了，赋值在准备阶段完成</li>
<li>如果 static 变量是 final 的，但属于引用类型和String的new，那么赋值也会在初始化阶段完成</li>
</ul>
<p>解析：将常量池中的符号引用解析为直接引用</p>
<ul>
<li>加载器的loadclass 方法不会导致类的解析和初始化</li>
<li>而new()则会解析和初始化</li>
</ul>
</blockquote>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a><strong>初始化阶段</strong></h2><blockquote>
<p><strong>初始化即调用 cinit()，虚拟机会保证这个类的『构造方法』的线程安全</strong><br><strong>概括得说，类初始化是【懒情的】</strong></p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
</blockquote>
<blockquote>
<p><strong>不会导致类初始化的情况</strong></p>
<ul>
<li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类的数组不会触发初始化</li>
<li>类加载器的 loadclass 方法</li>
<li>Class.forName 的参数2为 false 时</li>
</ul>
</blockquote>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a><strong>类加载器</strong></h1><blockquote>
<ul>
<li>启动类加载</li>
<li>扩展类加载器</li>
<li>应用程序类加载</li>
<li>自定义类加载<img src="http://hexo.xuxin.world/hexo/image-20220801172651812.png" width="80%" / loading="lazy"></li>
</ul>
</blockquote>
<h2 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a><strong>启动类加载器</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220801173205299.png" width="80%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220801173108680.png" width="80%" / loading="lazy">
打印结果是null说明是启动类加载器，因为它是c++写的，java无法直接访问
</blockquote>
<h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a><strong>双亲委派模式</strong></h2><blockquote>
<p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则<br>先查扩展类加载器，没有则找启动类加载器，如果还没有则走应用程序加载器</p>
</blockquote>
<h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a><strong>线程上下文类加载器</strong></h2><blockquote>
<p>线程上下文类加载器是在线程启动时jvm默认将应用程序类加载器给线程</p>
</blockquote>
<p><strong>SPI</strong></p>
<blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220802092226748.png" width="80%" / loading="lazy">
<img src="http://hexo.xuxin.world/hexo/image-20220802092505054.png" width="80%" / loading="lazy">
</blockquote>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a><strong>自定义类加载器</strong></h2><blockquote>
<p>类一样的定义：包名类名类加载器一样</p>
</blockquote>
<blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220802093004132.png" width="80%" / loading="lazy">
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Load extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String path = &quot;/Users/xuxin/workspace/jvm/out/production/ClassLoad/&quot;+name+&quot;.class&quot;;</span><br><span class="line">            ByteArrayOutputStream os = new ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path), os);</span><br><span class="line">            byte[] bytes = os.toByteArray();</span><br><span class="line">            return defineClass(name, bytes, 0, bytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new ClassNotFoundException(&quot;类文件未找到&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a><strong>运行期优化</strong></h1><img src="http://hexo.xuxin.world/hexo/image-20220802100709406.png" width="80%" / loading="lazy">

<h2 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a><strong>分层编译</strong></h2><blockquote>
<ul>
<li>0层：解释器，解释执行成平台无关机器码</li>
<li>1层：c1即时编译器（不带profile）</li>
<li>2层：c1即时编译器（基本profile）</li>
<li>3层：c1即时编译器（完全profile）</li>
<li>4层：c2即时编译器</li>
</ul>
<p>执行效率：解释器 &lt; c1 &lt; c2<br>因为大多数代码都是一次，不是多次执行，profile会统计方法调用次数等信息来分辨出热点代码，就是hotspot的由来</p>
</blockquote>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a><strong>逃逸分析</strong></h2><blockquote>
<p>会分析出哪些代码作用域外没有用到，直接不创建<br><strong>jvm参数</strong><br>-XX:+PrintCompilation -XX:-DoEscapeAnalysis  #关闭逃逸分析</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">        new Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当循环内的对象在外部没有引用时，c2即时编译期会将这段代码替换成空，不执行。</p>
<h2 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a><strong>方法内联</strong></h2><img src="http://hexo.xuxin.world/hexo/image-20220802101818902.png" width="60%" / loading="lazy">

<blockquote>
<p>jvm参数<br>-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining #打印内联情况<br>-XX:CompileCommand=dontinline,*JI72.squar   #禁用指定方法内联<br>-XX:+PrintCompilation</p>
</blockquote>
<h2 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a><strong>字段优化</strong></h2><blockquote>
<img src="http://hexo.xuxin.world/hexo/image-20220802102849510.png" width="50%" / loading="lazy">
方法是否内联影响其中字段成员的读取的优化
<img src="http://hexo.xuxin.world/hexo/image-20220802103129532.png" width="60%" / loading="lazy">
方法一如果内联会在机器码层面缓存一个local[]，从而减少1999次的Field读取
方法二则手动在内存里缓存了，相当于将机器码层面的缓存一样的效果
方法三则底层是方法二
</blockquote>
<h2 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a><strong>反射优化</strong></h2><blockquote>
<p>当反射调用方法时，会使用本地方法访问器来invoke。但当访问15次时候会由运行期动态生成的方法访问器。内部直接调用方法，而不是反射调用了<br><img src="http://hexo.xuxin.world/hexo/image-20220802104146595.png" width="80%" / loading="lazy"></p>
</blockquote>
<h1 id="JMM等"><a href="#JMM等" class="headerlink" title="JMM等"></a><strong>JMM等</strong></h1><blockquote>
<p>看JUC并发编程中详细介绍</p>
</blockquote>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>徐鑫</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/08/05/JVM/JVM/" title="JVM">http://example.com/2022/08/05/JVM/JVM/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/08/08/JUC/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="prev" title="JUC并发编程"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">JUC并发编程</span></a></div><div class="post-nav-item"></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 徐鑫</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>