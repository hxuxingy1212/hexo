<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="徐鑫"><meta name="copyright" content="徐鑫"><meta name="generator" content="Hexo 5.4.2"><meta name="theme" content="hexo-theme-yun"><title>JVM | 徐鑫的笔记</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.3.3/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"example.com","root":"/","title":"徐鑫的笔记","version":"1.10.6","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><meta name="description" content="初始JVM 定义：java virtual Machine java程序的运行环境（java二进制字节码的运行环境）好处  一次编写，到处运行（jvm屏蔽了java代码和操作系统的差异） 自动内存管理，垃圾回收（最重要，c语言是没有的，需要程序员手动管理，容易造成内存泄漏） 数组下标越界检查（c语言，会覆盖其他部分的内存而不是抛异常，前者更严重）   常见的jvm jvm是一套规范，只要符合这套规">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2022/08/05/JVM/JVM/index.html">
<meta property="og:site_name" content="徐鑫的笔记">
<meta property="og:description" content="初始JVM 定义：java virtual Machine java程序的运行环境（java二进制字节码的运行环境）好处  一次编写，到处运行（jvm屏蔽了java代码和操作系统的差异） 自动内存管理，垃圾回收（最重要，c语言是没有的，需要程序员手动管理，容易造成内存泄漏） 数组下标越界检查（c语言，会覆盖其他部分的内存而不是抛异常，前者更严重）   常见的jvm jvm是一套规范，只要符合这套规">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220512233116228.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220512233805569.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220713212959876.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220713214422254.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220714003720569.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220718164728251.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220718164814326.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220718173101635.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720150147347.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720150754325.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720151007691.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720153953209.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720154302553.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720161213902.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720161840089.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220720165150755.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220721172254593.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220722142732847.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220722143235835.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220722144005234.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220725142923128.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220725161623744.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220725163555413.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220726161153283.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727163332706.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727163451368.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727163506964.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727163805434.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727164017707.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727164232682.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727164251197.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727164622673.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165014132.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165105944.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165620095.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165819421.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727165956964.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170052203.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170111008.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170623468.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170752929.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727170825185.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727172308630.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727172323441.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220727172821946.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728155250306.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728155400364.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728155940787.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728155923536.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728160838675.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728160817007.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728163521477.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728163454476.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728164442556.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728164405696.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728165213010.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728165153568.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728165843690.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728165906682.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728171152614.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728171132935.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728171930029.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728172144342.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728172537845.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728172506834.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728173154742.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728172958363.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728173439549.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728173714430.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728173837362.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728174255057.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220728174210450.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143308943.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143509759.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143818352.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143831642.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729143856497.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729144034576.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729144137658.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729144858153.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729144925508.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729145322688.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729145347804.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729145414091.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729145302263.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220729150047364.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220801172651812.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220801173205299.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220801173108680.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802092226748.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802092505054.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802093004132.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802100709406.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802101818902.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802102849510.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802103129532.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802104146595.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802165659272.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802165615796.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802165537556.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802165501687.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802165413054.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802165400043.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802165346905.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802170855001.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802171700106.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802172406810.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802172439921.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802173449212.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802174926482.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802175026940.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802175126712.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220802175230071.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220803135702332.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220803151836823.png">
<meta property="og:image" content="http://hexo.xuxin.world/hexo/image-20220803153022260.png">
<meta property="article:published_time" content="2022-08-05T02:18:37.539Z">
<meta property="article:modified_time" content="2022-09-07T09:54:34.869Z">
<meta property="article:author" content="徐鑫">
<meta property="article:tag" content="java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hexo.xuxin.world/hexo/image-20220512233116228.png"><script>(function() {
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="徐鑫"><img width="96" loading="lazy" src="/images/touxiang2.jpg" alt="徐鑫"><span class="site-author-status" title="不想上学">😭</span></a><div class="site-author-name"><a href="/about/">徐鑫</a></div><span class="site-name">徐鑫的笔记</span><sub class="site-subtitle"></sub><div class="site-description">记录每一天所学</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">10</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qun.qq.com/qqweb/qunpro/share?_wv=3&amp;_wwv=128&amp;appChannel=share&amp;inviteCode=28OEdR&amp;appChannel=share&amp;businessType=9&amp;from=246610&amp;biz=ka" title="QQ 频道 - 小云之家" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.yunyoujun.cn/img/about/white-qrcode-and-search.jpg" title="微信" target="_blank" style="color:#1AAD19"><span class="icon iconify" data-icon="ri:wechat-2-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/albums/" title="相册" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:camera-fill"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8BJVM"><span class="toc-number">1.</span> <span class="toc-text">初始JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84jvm"><span class="toc-number">1.1.</span> <span class="toc-text">常见的jvm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">jvm结构图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">2.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">2.5.1.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%B1%A0%E6%AF%94%E8%BE%83"><span class="toc-number">2.5.2.</span> <span class="toc-text">三池比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E6%B1%A0"><span class="toc-number">2.5.3.</span> <span class="toc-text">串池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">判断回收对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.3.</span> <span class="toc-text">使用工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">判断根对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">5种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E5%99%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">终结器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97"><span class="toc-number">3.3.6.</span> <span class="toc-text">引用队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">复制算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">分代回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C"><span class="toc-number">3.6.1.</span> <span class="toc-text">串行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="toc-number">3.6.2.</span> <span class="toc-text">吞吐量优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="toc-number">3.6.3.</span> <span class="toc-text">响应时间优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.6.4.</span> <span class="toc-text">G1垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">3.7.</span> <span class="toc-text">性能调优</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">字节码指令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">类文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8Ainit"><span class="toc-number">4.2.</span> <span class="toc-text">字节码解释init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">字节码解释输出语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javap%E5%B7%A5%E5%85%B7"><span class="toc-number">4.4.</span> <span class="toc-text">javap工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E8%B5%8B%E5%80%BC"><span class="toc-number">4.5.</span> <span class="toc-text">从字节码角度分析赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90a"><span class="toc-number">4.6.</span> <span class="toc-text">从字节码角度分析a++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">4.7.</span> <span class="toc-text">从字节码角度分析流程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90x-0"><span class="toc-number">4.8.</span> <span class="toc-text">从字节码分析x&#x3D;0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90cinit"><span class="toc-number">4.9.</span> <span class="toc-text">从字节码分析cinit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90init"><span class="toc-number">4.10.</span> <span class="toc-text">从字节码分析init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">4.11.</span> <span class="toc-text">从字节码分析方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E5%A4%9A%E6%80%81"><span class="toc-number">4.12.</span> <span class="toc-text">从字节码分析多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.13.</span> <span class="toc-text">从字节码分析异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90syn"><span class="toc-number">4.14.</span> <span class="toc-text">从字节码分析syn</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">编译期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">5.0.1.</span> <span class="toc-text">默认构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-number">5.0.2.</span> <span class="toc-text">自动拆装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">5.0.3.</span> <span class="toc-text">范型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">5.0.4.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach"><span class="toc-number">5.0.5.</span> <span class="toc-text">foreach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swithc%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.0.6.</span> <span class="toc-text">swithc字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.0.7.</span> <span class="toc-text">switch枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">5.0.8.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-with-resource"><span class="toc-number">5.0.9.</span> <span class="toc-text">try-with-resource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%97%B6%E7%9A%84%E6%A1%A5%E6%8E%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.10.</span> <span class="toc-text">方法重写时的桥接方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.0.11.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">6.</span> <span class="toc-text">类加载阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">6.1.</span> <span class="toc-text">加载阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5"><span class="toc-number">6.2.</span> <span class="toc-text">链接阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">6.3.</span> <span class="toc-text">初始化阶段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.0.1.</span> <span class="toc-text">启动类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.0.2.</span> <span class="toc-text">双亲委派模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.0.3.</span> <span class="toc-text">线程上下文类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.0.4.</span> <span class="toc-text">自定义类加载器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">运行期优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">8.0.1.</span> <span class="toc-text">逃逸分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94"><span class="toc-number">8.0.2.</span> <span class="toc-text">方法内联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E4%BC%98%E5%8C%96"><span class="toc-number">8.0.3.</span> <span class="toc-text">字段优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="toc-number">8.0.4.</span> <span class="toc-text">反射优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM"><span class="toc-number">9.</span> <span class="toc-text">内存模型JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">9.0.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">9.0.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">9.0.3.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before"><span class="toc-number">9.0.4.</span> <span class="toc-text">happens-before</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">CAS与原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">10.0.1.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">10.0.2.</span> <span class="toc-text">底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">10.0.3.</span> <span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E4%BC%98%E5%8C%96"><span class="toc-number">10.0.4.</span> <span class="toc-text">synchronized优化</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="http://example.com/2022/08/05/JVM/JVM/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="徐鑫"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="徐鑫的笔记"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JVM</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2022-08-05 10:18:37" itemprop="dateCreated datePublished" datetime="2022-08-05T10:18:37+08:00">2022-08-05</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2022-09-07 17:54:34" itemprop="dateModified" datetime="2022-09-07T17:54:34+08:00">2022-09-07</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Java/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Java</span></a></span> > <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/Java/JVM/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">JVM</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/java/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">java</span></a><a class="tag-item" href="/tags/JVM/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">JVM</span></a></span></div><div class="post-author"><span class="author-name">徐鑫</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="初始JVM"><a href="#初始JVM" class="headerlink" title="初始JVM"></a><strong>初始JVM</strong></h1><blockquote>
<p><strong>定义：java virtual Machine java程序的运行环境（java二进制字节码的运行环境）</strong><br><strong>好处</strong></p>
<ul>
<li><strong>一次编写，到处运行（jvm屏蔽了java代码和操作系统的差异）</strong></li>
<li><strong>自动内存管理，垃圾回收（最重要，c语言是没有的，需要程序员手动管理，容易造成内存泄漏）</strong></li>
<li><strong>数组下标越界检查（c语言，会覆盖其他部分的内存而不是抛异常，前者更严重）</strong><img src="http://hexo.xuxin.world/hexo/image-20220512233116228.png" width="60%" loading="lazy"></li>
</ul>
</blockquote>
<h2 id="常见的jvm"><a href="#常见的jvm" class="headerlink" title="常见的jvm"></a><strong>常见的jvm</strong></h2><blockquote>
<p><strong>jvm是一套规范，只要符合这套规范，你可以自己实现，我们使用的hotspot，openJDK是可以自由使用且免费的</strong></p>
</blockquote>
<h2 id="jvm结构图"><a href="#jvm结构图" class="headerlink" title="jvm结构图"></a><strong>jvm结构图</strong></h2><blockquote>
<ul>
<li><strong>java程序编译成Class字节码文件时会进行一个编译优化</strong></li>
<li><strong>ClassLoader：类加载器，将字节码文件加载到jvm中去运行</strong></li>
<li><strong>MethodArea方法区：存放类</strong></li>
<li><strong>Heap堆：存放实例对象</strong></li>
<li><strong>JVMStacks，PC register程序计数器，NativeStacks本地方法栈：实例调用方法时会使用</strong></li>
<li><strong>Interpreter解释器：逐行解释java代码</strong></li>
<li><strong>JITCompiler即时编译器：会对热点代码优化</strong></li>
<li><strong>GC垃圾回收：回收堆中不需要的对象</strong></li>
<li><strong>本地方法接口：调用系统方法</strong><img src="http://hexo.xuxin.world/hexo/image-20220512233805569.png" width="80%" loading="lazy"></li>
</ul>
</blockquote>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a><strong>内存结构</strong></h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h2><blockquote>
<p><strong>定义</strong><br>Program Counter Register 程序计数器（寄存器）</p>
</blockquote>
<blockquote>
<p><strong>作用</strong><br>二进制字节码文件对应有很多条jvm指令，当一条指令执行时，程序计数器会记住下一条指令的地址，指令执行完后会再记住下一条的地址，解释器再到程序计数器里取再解释成机器码交给cpu执行<br><img src="http://hexo.xuxin.world/hexo/image-20220713212959876.png" alt="image-20220713212959876" loading="lazy"><br><strong>为什么用寄cpu里寄存器来当程序计数器？</strong><br>因为取地址这个操作是很频繁的，所以执行速度一定要快，寄存器是cpu最快的单元<br><strong>特点</strong></p>
<ul>
<li>是线程私有的（每个线程都有自己的程序计数器）</li>
<li>不会存在内存溢出（唯一一个部分不会存在，jvm规范规定的，厂商不需要再考虑）</li>
</ul>
</blockquote>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h2><blockquote>
<p><strong>定义</strong><br>Jaya Virtual Machine Stacks (Java 虚拟机栈）</p>
<ul>
<li>栈：线程运行需要的内存空间</li>
<li>栈帧：每个方法运行时需要的内存（参数，局部变量，返回的地址）</li>
<li>栈由栈帧组成，一个栈帧代表一次方法的调用•每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的內存</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法<img src="http://hexo.xuxin.world/hexo/image-20220713214422254.png" width="50%" loading="lazy"></li>
</ul>
</blockquote>
<p><strong>问题辨析</strong></p>
<blockquote>
<ol>
<li><strong>垃圾回收是否涉及栈内存？</strong><br> 不涉及，因为一个方法调用结束后，方法内部产生的变量等内容会跟着方法一起出栈</li>
<li><strong>栈内存分配越大越好吗？</strong><br> 可以通过-Xss设置栈内存，默认是1Mb，并不是越大越好，反而会减少可创建的线程数量，只是方法可以被递归调用的次数变多而已</li>
<li><strong>方法内的局部变量是否线程安全？</strong><br> 一般情况是，因为局部变量是线程私有的，每个线程都会有自己的栈，线程调用方法时，局部变量是在自己的活动栈帧里，几个线程就有几个局部变量，互不干扰<br> 但是，如果这个局部变量作为返回值返回，那么其他线程也能访问了，需要判断这个变量是否逃离了方法的作用范围</li>
</ol>
</blockquote>
<p><strong>辨析String家族</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//线程安全，StringBuilder是局部变量，线程各自创建，互不影响</span><br><span class="line">public static void m1() &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(1);</span><br><span class="line">    sb.append(2);</span><br><span class="line">    sb.append(3);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程不安全，sb是引用类型，其他线程也能访问</span><br><span class="line">public static void m2(StringBuilder sb) &#123;</span><br><span class="line">    sb.append(1);</span><br><span class="line">    sb.append(2);</span><br><span class="line">    sb.append(3);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程安全，StringBuffer的方法会被synchronized修饰</span><br><span class="line">public static void m3(StringBuffer sb) &#123;</span><br><span class="line">    sb.append(1);</span><br><span class="line">    sb.append(2);</span><br><span class="line">    sb.append(3);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line">//不安全，作为结果返回，其他线程也会拿到这个变量</span><br><span class="line">public static StringBuilder m4() &#123;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(1);</span><br><span class="line">    sb.append(2);</span><br><span class="line">    sb.append(3);</span><br><span class="line">    return sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈内存溢出</strong></p>
<p>异常：<strong>java.lang.StackOverflowError</strong></p>
<ul>
<li>栈帧过多（递归调用没有设立终止条件）</li>
<li>栈帧过大（一般不可能）</li>
</ul>
<p>举例：当json转换时，如果俩个实体互相包含，那么会抛出这个栈溢出的异常，需要手动在实体上添加@JsonIgnore</p>
<p><strong>线程诊断</strong></p>
<p>CPU诊断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看cpu使用情况，断定哪一个pid的进程占用高</span><br><span class="line">top</span><br><span class="line">#查看所有线程根据pid过滤的使用情况</span><br><span class="line">ps H -eo pid,tid,%cpu I grep 32655</span><br><span class="line">#可以查看进程里线程的执行情况，根据ps命令可以看到tid的信息，16进制转换后，找到对应线程，可以定位到具体的代码的行数</span><br><span class="line">jstack pid</span><br></pre></td></tr></table></figure>

<p>长时间没有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#可能发生了线程死锁</span><br><span class="line">#java -jar运行后会有pid</span><br><span class="line"></span><br><span class="line">jstack pid</span><br><span class="line"></span><br><span class="line">#最底部会出现死锁的提示信息，可以查看多个线程的那一行代码出现问题</span><br></pre></td></tr></table></figure>

<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈：java调用本地方法时需要的内存空间</p>
<p>本地方法：不是由java代码编写的，被native修饰的，比如Object的clone，wait等</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>其他</strong></p>
<p><strong>异常：java. lang. OutofMemoryError</strong></p>
<p><strong>参数：-Xmx：最大堆大小，-Xms：初始堆大小</strong></p>
<p><strong>默认堆内存大小</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">除非在命令行上指定了初始堆大小和最大堆大小，否则它们将根据计算机上的内存量进行计算。</span><br><span class="line"></span><br><span class="line">最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一在32位JVM上，如果有4 GB或更多的物理内存，则默认的最大堆大小最多可以为1 GB。在64位JVM上，如果有128GB或更多的物理内存，则默认的最大堆大小最大为32 GB。</span><br><span class="line">在JVM初始化期间分配了一个较小的值，称为初始堆大小。此数量至少为8 MB，否则为物理内存的1/64，最大为1 GB。分配给年轻代的最大空间量是堆总大小的三分之一，即年轻代和老年代默认的比例是1:2</span><br><span class="line">您可以使用-Xms（初始堆大小）和-Xmx（最大堆大小）来指定初始堆大小和最大堆大小。如果你知道你的应用程序有多少堆需要工作做好，你可以设置-Xms和-Xmx相同的值。否则，JVM将使用初始堆大小开始，然后将增大Java堆，直到找到堆使用率和性能之间的平衡为止。</span><br></pre></td></tr></table></figure>

<p><strong>定义</strong></p>
<p><strong>使用new创建的对象都会使用堆内存来存放</strong></p>
<p><strong>特点</strong></p>
<ul>
<li><strong>线程共享，堆中对象都需要考虑线程安全问题</strong></li>
<li><strong>有垃圾回收机制</strong></li>
</ul>
<p><strong>堆内存溢出诊断</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.jps 工具</span><br><span class="line">查看当前系统中有哪些 java 进程</span><br><span class="line">2.jmap 工具</span><br><span class="line">查看堆內存占用情况 jmap -heap 进程id</span><br><span class="line">3. jconsole 工具</span><br><span class="line">图形界面的，多功能的监测工具，可以连续监测</span><br><span class="line">4.可视化虚拟机，可以获取前多少的最大堆内存占用的对象找不来，并且可以生成快照分析</span><br><span class="line">jvisualym</span><br></pre></td></tr></table></figure>

<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p><strong>定义</strong></p>
<p>异常：java. lang. OutofMemoryError</p>
<p>定义：是一个所有java线程共享的区域，存储了跟类的结构相关的信息，包括成员变量，方法数据，成员方法，构造器，类加载器以及运行时常量池，它从虚拟机启动时创建，逻辑上是堆的一部分，但是并不强制它的位置</p>
<p>hotspot 1.8以前使用了永久代就是使用堆的一部分作为方法区，1.8以后引入元空间，使用的是本地内存（操作系统的内存）</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220714003720569.png" alt="image-20220714003720569" loading="lazy"></p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ul>
<li>1.8以前会导致永久代内存溢出，32位JVM的默认最大内存大小为64 MB，64位版本为82 MB</li>
<li>1.8之后会导致元空间內存溢出，默认是操作系统的内存，可以设置参数</li>
</ul>
<p>元空间异常：java.lang. OutofMemoryError：Metaspace</p>
<p>参数：-XX: MaxMetaspacesize 最大内存，-XX:MetaspaceSize 初始内存</p>
<p>永久代异常：java.lang.OutofMemoryError: PermGen space</p>
<p>参数：-XX:MaxPermsize=8m，</p>
<p>场景：</p>
<ul>
<li>spring</li>
<li>mybatis</li>
</ul>
<p>都使用了cglib动态代理，会在运行时创建类的字节码对象</p>
<h3 id="三池比较"><a href="#三池比较" class="headerlink" title="三池比较"></a>三池比较</h3><p>反编译 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v Helloworld.class</span><br></pre></td></tr></table></figure>

<p>定义</p>
<ul>
<li>Class常量池：每一个class文件都有一个常量池，常量池保存着class的常量信息：字面量和符号引用，编译时产生</li>
<li>运行时常量池：当该类被加载解析后生成，一个Class对应一个，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
<li>串池：就是在运行时保存字符串的池子，被放在堆中，而且全局唯一</li>
</ul>
<h3 id="串池"><a href="#串池" class="headerlink" title="串池"></a>串池</h3><p><strong>定义</strong></p>
<ul>
<li>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个Hash表，默认值大小长度是1009；这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了StringTable上。</li>
<li>在JDK6.0中，StringTable的长度是固定的，因此如果放入String Pool中的String非常多，就会造成hash冲突，导致链表过长，当调用String#intern()时会需要到链表上一个一个找，从而导致性能大幅度下降；</li>
<li>在JDK7.0中，StringTable的长度可以通过参数指定：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=66666</span><br></pre></td></tr></table></figure>

<p><strong>特性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.常量池中的字符串仅是符号，第一次用到时才变为对象</span><br><span class="line">2.利用串池的机制，来避免重复创建字符串对象</span><br><span class="line">3.字符串变量拼接的原理是 StringBuilder (1.8)</span><br><span class="line">4.字符串常量拼接的原理是编译期优化</span><br><span class="line">5.可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池</span><br><span class="line">		1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象</span><br><span class="line">返回</span><br><span class="line">		1.6將这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象</span><br><span class="line">返回</span><br></pre></td></tr></table></figure>

<p><strong>位置</strong></p>
<p>1.6:永久代的方法区中</p>
<p>1.7:堆中</p>
<p>1.8直接取消了永久代，改为本地内存的元空间</p>
<p><strong>为什么要移出永久代</strong></p>
<ul>
<li>在原来的永久代划分中，永久代需要存放类的元数据、静态变量和常量等。它的大小不容易确定，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等，-XX:MaxPermSize 指定太小很容易造成永久代内存溢出。</li>
<li>移除永久代是为融合HotSpot VM与 JRockit VM而做出的努力，因为JRockit没有永久代，不需要配置永久代。</li>
<li>永久代会为GC带来不必要的复杂度，并且回收效率偏低</li>
</ul>
<p><strong>性能调优</strong></p>
<ul>
<li>减少哈希表长度</li>
<li>合理使用串池</li>
</ul>
<p><strong>减少哈希表长度</strong></p>
<p>原理：StringTable是一个哈希表，String.intern每调用一次都会查找串池，查找效率和哈希表的长度有关，长度越长哈希冲突的概率越小</p>
<p>-XX：+PrintStringTableStatistics      打印StringTable信息</p>
<p>-XX: StringTableSize=1009                 设置串池大小</p>
<p><strong>合理使用串池</strong></p>
<p>原理：相同的字符串只能存一份，当大量字符串且其中有大量重复时，可以存进串池中，而不是堆内存，从而减少堆内存的消耗</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>Direct Memory</p>
<ul>
<li>常见于 NIO 操作时，用于数据缓冲区</li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JM内存回收管理</li>
<li>操作系统的内存</li>
</ul>
<p><strong>使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DirectMemory &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024 * 1024);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.out.println(&quot;开始回收&quot;);</span><br><span class="line">        byteBuffer = null;</span><br><span class="line">        System.gc();//显式的拉圾回收，Full GC</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么读写快？</strong></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220718164728251.png" alt="image-20220718164728251" style="zoom: 33%;" / loading="lazy"><img src="http://hexo.xuxin.world/hexo/image-20220718164814326.png" alt="image-20220718164814326" style="zoom: 33%;" / loading="lazy"></p>
<p>直接内存，java代码和cpu都能直接访问，而不用从系统内存复制一份到java堆内存来让java代码可以访问</p>
<p><strong>内存溢出</strong></p>
<p>也会发生内存溢出情况，不过是基于操作系统的内存，较大</p>
<p><strong>释放原理</strong></p>
<p>java垃圾回收不管理直接内存，直接内存的释放需要主动调用unsafe. freeMemory(base)方法，借助了java中的虚引用机制，当虚引用对象被回收时，会触发定时任务，清理创建的直接内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法</span><br><span class="line">ByteBuffer 的实现类内部，使用了 cleaner（虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃</span><br><span class="line">圾回收，那么就会由 ReferenceHandler 线程通过 Cleanqr 的 clean 方法调用 freeMemory 来释放直接内存</span><br></pre></td></tr></table></figure>

<p><strong>禁用显式垃圾回收对直接内存的影响</strong></p>
<p>-XX:+DisableExplicitGc 关闭显式垃圾回收</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();//显式的拉圾回收，Full GC</span><br></pre></td></tr></table></figure>

<p>影响：会使直接内存长时间没法回收，造成内存溢出</p>
<p>解决：使用unsafe.freeMemory来手动释放内存</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="判断回收对象"><a href="#判断回收对象" class="headerlink" title="判断回收对象"></a>判断回收对象</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>描述：当一个对象被引用时计数加1，当一个对象取消引用计数减1，为0时回收</p>
<p>缺点：<img src="http://hexo.xuxin.world/hexo/image-20220718173101635.png" alt="image-20220718173101635" style="zoom:33%;" / loading="lazy">当存在俩个对象互为引用时，则永远无法被回收</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>根对象：不能被回收的对象</p>
<p>描述：堆中被根引用或间接引用的不会被垃圾回收，其余被回收</p>
<h3 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jps 查看进程id</span><br><span class="line">jmap抓取程序，将其转储为二进制文件</span><br><span class="line">dump转储，format=b二进制格式，live执行一次垃圾回收只保留存活的，file=1.bin文件名，21384进程id</span><br><span class="line">jmap -dump: format=b,live,file=l.bin 21384</span><br></pre></td></tr></table></figure>

<h2 id="判断根对象"><a href="#判断根对象" class="headerlink" title="判断根对象"></a>判断根对象</h2><p>SystemClass 系统对象</p>
<p>Thread    存活的线程对象</p>
<p>BusyMonitor 同步synchronized的对象</p>
<p>NativeStack 本地方法中被引用的对象</p>
<h2 id="5种引用"><a href="#5种引用" class="headerlink" title="5种引用"></a>5种引用</h2><ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
<li>终结器引用</li>
</ul>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收，换句话说就是，只要强引用存在，JVM 垃圾回收器就永远都不会回收被引用的对象，即使内存不足，JVM 会抛出 OutOfMemoryError</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//只要 obj 指向 Object 对象，那它就永远都不会被 JVM 回收</span><br><span class="line">Object obj = new Object();</span><br><span class="line">//将 obj 置为 null，可以切断引用链，这样 obj 就会被 JVM 回收</span><br><span class="line">obj = null;</span><br></pre></td></tr></table></figure>

<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象，即在内存足够时，JVM 不会回收软引用对象，但当内存不足时，软引用对象就会被回收，所以软引用对象通常用来描述一些非必要但仍有用的对象。</p>
<p><strong>软引用的使用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM参数 ： -Xmx20m -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    //关联了引用队列，当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span><br><span class="line">    SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[1024 * 1024 * 4], queue);</span><br><span class="line">    System.out.println(ref.get());</span><br><span class="line">    list.add(ref);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//从队列中获取无用的软引用对象，并从list中移出</span><br><span class="line">Reference&lt;? extends byte[]&gt; poll = queue.poll();//获取最先进入队列的元素，移出队列并返回</span><br><span class="line">while (poll != null) &#123;</span><br><span class="line">    list.remove(poll); //list中移出这个元素</span><br><span class="line">    poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (SoftReference&lt;byte[]&gt; reference : list) &#123;</span><br><span class="line">    System.out.println(reference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用是较软引用更第低一级的引用，只要发生垃圾回收，无论内存是否充足，JVM 都会回收掉弱引用对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p>
<h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要重写了finalize方法，虚拟机自动创建终结器引用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程（优先级很低）通过终结器引用找到被引用对象并调用 finalize 方法，第二次 GC 时回收被引用对象</span><br></pre></td></tr></table></figure>

<p>强烈不推荐，可能导致性能问题，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%AD%BB%E9%94%81&spm=1001.2101.3001.7020">死锁</a>，挂起和其他问题行为”，并且因为“终结的时间无法预测，无法保证将调用终结器</p>
<h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>目的：垃圾回收回收的是对象，而引用可以由引用队列来回收。</p>
<p>软引用和弱引用可以使用引用队列来回收引用，虚引用必须配合引用队列使用，终结器有自己的引用队列，无需编码。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>标记：标记哪些不是GcRoot引用的，需要被清除的</p>
<p>清楚：将起始结束地址放入空闲队列，如果有需要新的内存，再看看是否满足，满足就覆盖，不会清0操作</p>
<p>优点：速度快，没有额外处理</p>
<p>缺点：没有整理，空间不连续，容易出现内存碎片，大的内存需要时，还是会造成内存溢出</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220720150147347.png" alt="image-20220720150147347" loading="lazy"></p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>思路：和上一个一样</p>
<p>优点：没有碎片</p>
<p>缺点：速度慢，整理时，所有相关的地址都需要相应改变，工作量大，在存活较多时适合</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220720150754325.png" alt="image-20220720150754325" loading="lazy"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>思路：先标记，然后将存活的放入to内存空间中，再清空from，再将to和from交换</p>
<p>优点：没有碎片</p>
<p>缺点：需要双倍的内存空间，适合存活较少时</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220720151007691.png" alt="image-20220720151007691" loading="lazy"></p>
<h2 id="分代回收机制"><a href="#分代回收机制" class="headerlink" title="分代回收机制"></a>分代回收机制</h2><p><strong>分代垃圾回收的介绍</strong></p>
<p>老年代：存放长时间使用的</p>
<p>新生代：需要频繁被回收的</p>
<p><strong>结构</strong></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220720153953209.png" alt="image-20220720153953209" loading="lazy"></p>
<p><strong>流程</strong></p>
<ul>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间(伊甸园)不足时，触发 minor gc，伊甸园和 from 存活的对象使用复制算法复制到to 中，存活的对象年龄加1并且交换 from和 to的指向</li>
<li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>当对象寿命超过國值时，会晋升至老年代，最大寿命是15 (4bit)</li>
<li>当有大对象，直接超过了新生代的大小，那么会直接到老年代，不会出发minor gc，如果新生代存不下了，会先minor gc，如果还存不下，会直接存到老年代。</li>
<li>幸存区空间满了，会触发minor gc，一部分晋升老年代，一部分移到to幸存区。</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 foll gc, STW的时间更长</li>
</ul>
<p><strong>VM相关参数</strong></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220720154302553.png" alt="image-20220720154302553" loading="lazy"></p>
<p><strong>其他</strong></p>
<p>当子线程出现内存溢出时，不会影响主线程的运行</p>
<p>当有大对象，直接超过了新生代的大小，那么会直接到老年代</p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul>
<li>单线程 </li>
<li>堆内存较小，适合个人电脑</li>
</ul>
<p>开启串行垃圾回收器vm参数：-XX:+UseSerialGC = Serial+Serialold</p>
<p>Serial:新生代垃圾回收器，采用复制算法</p>
<p>Serialold:老年代垃圾回收器，采用标记整理算法</p>
<p>流程：<img src="http://hexo.xuxin.world/hexo/image-20220720161213902.png" alt="image-20220720161213902" loading="lazy"></p>
<h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><ul>
<li>多线程</li>
<li>堆内存较大，多核cpu</li>
<li>让单位时间内，STW的时间最短</li>
</ul>
<p><strong>vm参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC ~ -XX:+UseParalleloldGC  </span><br><span class="line">jdk8默认的,前一个是年轻代，采用复制算法，后一个是老年代，采用标记整理算法，只要开启一个，另一个也自动开启</span><br><span class="line"></span><br><span class="line">其他配置参数，其中2，3冲突，只能存在一个</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 使用自适应大小策略，会调整新生代的伊甸园和幸存区的大小，也会调整整个堆的大小</span><br><span class="line">-XX:GCTimeRatio=ratio  #吞吐量指标:1/(1+ratio)默认ratio为99,当一次垃圾回收没有达到这个指标，会调整堆大小来适应</span><br><span class="line">-XX : MaxGCPauseMillis=ms #最大暂停毫秒数，默认200，当一次垃圾回收没有达到这个指标，会调整堆大小来适应</span><br><span class="line">-XX:ParallelGCThreads=n  可以限制并行垃圾回收的线程数</span><br></pre></td></tr></table></figure>

<p><img src="http://hexo.xuxin.world/hexo/image-20220720161840089.png" alt="image-20220720161840089" loading="lazy"></p>
<p>垃圾回收线程的个数和cpu一样（在cpu个数&lt;某个值），所以垃圾回收时，cpu占用率达到100%，当然可以使用参数限制线程数。</p>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul>
<li>多线程</li>
<li>堆内存较大，多核cpu</li>
<li>尽可能让单词STW的时间最短</li>
</ul>
<p>vm参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC ～ -XX:+UseParNewGC - Serialold</span><br><span class="line">第一个是并发标记清楚的老年代垃圾回收器，与之配合使用的是第二个基于复制算法的新生代垃圾回收器，第三个是第一个出现并发失败时的一个补救措施，让老年代单线程垃圾回收器来整理碎片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</span><br><span class="line">第一个并行的线程数和前面一样，第二个是并发的线程数一般为第一个的1/4</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br><span class="line">执行CMS垃圾回收的内存占比，因为运行后产生的垃圾没法这次清理，所以需要预留一点内存给浮动垃圾，早期是60%</span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br><span class="line">在重新标记前执行一次新生代垃圾回收，减轻重新标记的压力</span><br></pre></td></tr></table></figure>

<p>流程<img src="http://hexo.xuxin.world/hexo/image-20220720165150755.png" alt="image-20220720165150755" loading="lazy"></p>
<p><strong>初始标记</strong>：只会标记GC Roots，不会Tracing，速度很快</p>
<p><strong>并发标记</strong>：GC Roots Tracing标记整个可达对象的引用链</p>
<p>注意: 并发标记阶段做完GC Roots Tracing后为了减轻重新标记阶段的负担，会提前做重新标记阶段的工作，并发标记阶段采取并发预处理策略和可中断的并发预处理策略来进行重新标记阶段的工作。</p>
<p><strong>重新标记</strong>：修改并发标记因用户程序变动的内容</p>
<p>重新标记阶段需要标记old区所有的存活对象，除了标记CG Root直接指向old区的引用链还要标记GC Root通过young区对象指向到old区对象的引用链，如果young区对象过多可以强制进行minor gc可以设置参数-XX:+CMSScavengeBeforeRemark。</p>
<p>注意：这个垃圾回收器没有整理碎片，如果内存不足时，产生并发失败，会让老年代单线程来整理 </p>
<h3 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h3><p>定义：Garbage First</p>
<p>2004 论文发布<br>2009 JDK 6u14 体验<br>2012 JDK 714 官方支持<br>2017 JDK 9 默认<br><strong>适用场景</strong></p>
<ul>
<li>同时注重吞吐量(Throughput）和低延迟(Low latency)，默认的暂停目标是200 ms</li>
<li>超大堆內存，会将堆划分为多个大小相等的 Region</li>
<li>整体上是标记+整理算法，两个区域之间是复制算法</li>
</ul>
<p><strong>相关JVM参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XX:+UseG1GC  #jdk8还不是默认的，需要指定</span><br><span class="line">-XX:G1HeapRegionSize=size  #region的大小划分</span><br><span class="line">-XX:MaxGCPauseMillis=time  #默认暂停时间，默认是200ms</span><br></pre></td></tr></table></figure>

<p><strong>G1垃圾回收流程</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220721172254593.png" alt="image-20220721172254593" style="zoom:33%;" / loading="lazy">

<p>新生代——&gt;新生代+并发标记——&gt;混合收集(年轻代加老年代)</p>
<p>新生代垃圾回收：和其他一样会触发STW，同时在这个STW里会初始标记GC root，多个region作为eden，当eden满了，会出发新生代垃圾回收，使用复制算法，复制到幸存区，幸存区满了后，会触发垃圾回收,一部分会晋升老年代，一部分会用复制算法移动其他幸存区（to），此外eden满的也会移动到新的幸存区</p>
<p>新生代+并发标记：当老年代占总内存的一个阈值时，会做并发标记（不会STW），和CMS一样工作线程继续，其中并发线程做标记</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx: InitiatingHeapOccupancyPercent=percent （默认45%)并发标记阈值</span><br></pre></td></tr></table></figure>

<p>混合收集：先新生代回收，最终标记（会STW），老年代会使用复制算法，有选择的将回收价值大的老年代回收，复制到其他老年代，其中最终标记和拷贝存活会STW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=ms  最大暂停时间，默认200ms</span><br></pre></td></tr></table></figure>

<p><strong>G1回收细节详解</strong></p>
<p>①. G1回收过程一：年轻代GC<br>回收时机<br>(1). 当Eden空间耗尽时,G1会启动一次年轻代垃圾回收过程<br>(2). 年轻代垃圾回收只会回收Eden区和Survivor区</p>
<p>第一阶段，根扫描:</p>
<ul>
<li>会触发STW，同时在这个STW里会初始标记GC root</li>
<li>一定要考虑remembered Set,看是否有老年代中的对象引用了新生代对象</li>
<li>根引用连同RSet记录的外部引用作为扫描存活对象的入口</li>
</ul>
<p>第二阶段，更新RSet:</p>
<p>当有老年代引用新生代时，标记这个对象所在的card为脏card，新生代region会有一个Remembered Set记录外部引用。减少了找GCroot的时间。当引用变更时，会被写屏障一个程序拦截，会放入一个脏卡更新队列中，让一个线程去异步更新RememberedSet。</p>
<p>第三阶段，处理RSet:</p>
<p>识别被老年代对象指向的Eden中的对象,这些被指向的Eden中的对象被认为是存活的对象<br>第四阶段，复制对象:</p>
<p>此阶段,对象树被遍历,Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段,Survivor区内存段中存活的对象如果年龄未达阈值,年龄会加1,达到阀值会被会被复制到old区中空的内存分段。如果Survivor空间不够,Eden空间的部分数据会直接晋升到老年代空间<br>第五阶段，处理引用:</p>
<p>处理Soft,Weak, Phantom, Final, JNI Weak等引用。</p>
<p>②. 回收过程二：新生代+并发标记过程<br>一、初始标记阶段:</p>
<p>GCroot初始标记，在年轻代回收时就做了</p>
<p>二、并发标记(Concurrent Marking):</p>
<p>在整个堆中进行并发标记(和应用程序并发执行)。在并发标记阶段,若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时,并发标记过程中,会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<p>四、再次标记(Remark):</p>
<p>由于应用程序持续进行,需要修正上一次的标记结果。是STW的。<br>五、独占清理(cleanup,STW):</p>
<p>计算各个区域的存活对象和GC回收比例,并进行排序,识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)<br>六、并发清理阶段:</p>
<p>识别并清理完全空闲的区域</p>
<p>③. 混合回收 Mixed GC<br>先新生代回收，最终标记（会STW），老年代会使用复制算法，有选择的将回收价值大的老年代回收，复制到其他老年代，其中最终标记和拷贝存活会STW</p>
<p>注意：会优先回收价值大的区域，以满足-XX:MaxGCPauseMillis=ms  最大暂停时间，默认200ms</p>
<p>④. G1的可选过程四：Full GC<br>G1会停止应用程序的执行(Stop-The-World) ，使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>导致G1Full GC的原因可能有: .</p>
<ul>
<li>回收的时候没有足够的to-space来存放晋升的对象</li>
<li>处理过程没完成空间就耗尽了</li>
<li>当垃圾产生速度快于回收速度时会触发fullGC此时会转到单线程做较长的STW</li>
</ul>
<p><strong>FullGC</strong></p>
<p>SerialGC</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足发生的垃圾收集 - full gc</li>
</ul>
<p>ParallelGC</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gC</li>
<li>老年代内存不足发生的垃圾收集 - full ge</li>
</ul>
<p>CMS</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存不足不叫，并发失败以后才叫，转到单线程做较长的STW</li>
</ul>
<p>Gl</p>
<ul>
<li>新生代内存不足发生的垃圾收集 - minor gc</li>
<li>老年代内存达到一定百分比时还不叫，当垃圾产生速度快于回收速度时会触发fullGC此时会转到单线程做较长的STW</li>
</ul>
<p><strong>新生代跨代回收</strong></p>
<p>新生代回收需要标记Gcroot对象，当有新生代对象被老年代引用时，需要遍历老年代，此时速度很慢，将老年代按大小拆分成固定大小的card，当有老年代引用新生代时，标记这个对象所在的card为脏card，新生代region会有一个Remembered Set记录外部引用。减少了找GCroot的时间。当引用变更时，会被写屏障一个程序拦截，会放入一个脏卡更新队列中，让一个线程去异步更新RememberedSet。</p>
<img src="http://hexo.xuxin.world/hexo/image-20220722142732847.png" alt="image-20220722142732847" style="zoom: 50%;" / loading="lazy">

<p><strong>Remark</strong></p>
<p>并发标记阶段：当有引用变更时，会被写屏障拦截，放入一个队列中，并将其标记为灰色，表示正在处理，当并发阶段结束后，进入重新标记阶段，会STW，将队列中的对象取出，并检查，</p>
<img src="http://hexo.xuxin.world/hexo/image-20220722143235835.png" alt="image-20220722143235835" style="zoom:50%;" / loading="lazy">

<p><strong>G1字符串去重</strong></p>
<p>jdk8u20</p>
<img src="http://hexo.xuxin.world/hexo/image-20220722144005234.png" alt="image-20220722144005234" style="zoom: 50%;" / loading="lazy">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UsestringDeduplication（bool）：开启 String 去重，默认是不开启的，需要手动开启。</span><br><span class="line"></span><br><span class="line">Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息。</span><br></pre></td></tr></table></figure>

<p>String中的char[] 如果相同只会存在一个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;abc&quot;);</span><br><span class="line">String s2 = new String(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    Field value1 = s1.getClass().getDeclaredField(&quot;value&quot;);</span><br><span class="line">    Field value2 = s2.getClass().getDeclaredField(&quot;value&quot;);</span><br><span class="line">    value1.setAccessible(true);</span><br><span class="line">    value2.setAccessible(true);</span><br><span class="line">    char[] o1 = (char[]) value1.get(s1);</span><br><span class="line">    char[] o2 = (char[]) value2.get(s2);</span><br><span class="line"></span><br><span class="line">    o1[0] = &#x27;c&#x27;;</span><br><span class="line">    System.out.println(o2[0]);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类卸载</strong></p>
<p>Jdk8u40</p>
<p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它<br>所加载的所有类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx:+ClassUnloadingwithConcurrentMark 默认启用</span><br></pre></td></tr></table></figure>

<p><strong>巨型对象回收</strong></p>
<ul>
<li>—个对象大于 region 的一半时，称之为巨型对象</li>
<li>G1 不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1 会跟踪老年代所有 incomig引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><img src="http://hexo.xuxin.world/hexo/image-20220725142923128.png" alt="image-20220725142923128" loading="lazy"></p>
<p><strong>JDK9 并发标记起始时间的调整</strong></p>
<ul>
<li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li>
<li>JDK 9 之前需要使用 -xx: InitiatingHeapOccupancyPercent</li>
<li>JDK 9 可以动态调整</li>
<li><ul>
<li>-xx:InitiatingHeapoccupancyPercent 用来设置初始值</li>
<li>进行数据采样并动态调整</li>
<li>总会添加一个安全的空档空间1</li>
</ul>
</li>
</ul>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><p><strong>查看虚拟机运行参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看本地jdk默认参数</span><br><span class="line">/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin/java -XX:+PrintFlagsFinal -version / findstr &quot;Gc&quot;</span><br><span class="line"></span><br><span class="line">查看官方文档虚拟机参数</span><br><span class="line">https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#overview-of-java-options</span><br></pre></td></tr></table></figure>

<p><strong>调优方向</strong></p>
<ul>
<li><strong>内存</strong></li>
<li><strong>锁竞争</strong></li>
<li><strong>cpu 占用</strong></li>
<li><strong>io</strong></li>
</ul>
<p><strong>调优目标</strong></p>
<p>【低延迟】还是【高吞吐量】，选择合适的回收器</p>
<ul>
<li>cMs, GI, ZGC</li>
<li>ParallelGC</li>
<li>Zing（不是hotspot）</li>
</ul>
<p><strong>最快的GC 是不发生GC</strong></p>
<p>数据是不是太多？<br>    resultSet = statement.executeQuery(“seleet * from 大表 limit n”)<br>数据表示是否太臃肿？<br>    对象图<br>    对象大小 16 Integer 24 int 4<br>是否存在内存泄漏？<br>    static Map map …              不要存在那种一直存在(强引用)并且不断添加元素，从不回收的对象<br>    软，弱                             使用软，弱引用，使对象可以回收<br>    第三方缓存实现                       缓存使用第三方缓存不要自己new一个map</p>
<p><strong>新生代的调优</strong></p>
<p>新生代速度远小于老年代，所以应该先从老年代开始</p>
<ul>
<li><p>所有的 new 操作的内存分配非常廉价</p>
<p>​        TLAB thread-local allocation buffer（创建对象会在线程eden的线程缓存区中创建）</p>
</li>
<li><p>死亡对象的回收代价是零</p>
</li>
<li><p>大部分对象用过即死</p>
</li>
<li><p>Minor GC 的时间远远低于 Full Gc</p>
</li>
</ul>
<p><strong>一、-Xmn 设置新生代内存大小</strong></p>
<p>这个值最好设置成（并发量  *（一次请求到响应）的数据</p>
<p>因为一次请求到响应的数据都是用过即死，这样设置会较少触发minorGC</p>
<p><strong>二、幸存区调优</strong></p>
<ol>
<li>幸存区大到能保留【当前活跃对象+需要晋升对象】</li>
</ol>
<p>因为幸存区太小，jvm会动态调整晋升阈值，使得那些本来要被回收的晋升到老年代了</p>
<ol start="2">
<li><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold=threshold   晋升阈值</span><br><span class="line">-XX:+PrintTenuringDistribution			 打印各年龄的内存占用大小</span><br></pre></td></tr></table></figure></li>
</ol>
<img src="http://hexo.xuxin.world/hexo/image-20220725161623744.png" alt="image-20220725161623744" style="zoom:50%;" / loading="lazy">

<p><strong>老年代调优</strong></p>
<p>以CMS 为例</p>
<ul>
<li>CMS 的老年代内存越大越好</li>
<li>先尝试不做调优，如果没有 Full Gc 那么已经…，否则先尝试调优新生代</li>
<li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4~1/3</li>
</ul>
<p>-XX:CMSInitiatingOccupancyFraction=percent 老年代垃圾占内存比例，达到时做垃圾回收</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.cpu可以的话，极端情况下可以设置为0，只要有垃圾就开启回收，使得没有浮动垃圾，不会做fullGc，但对cpu要求较高，需要始终有一个线程来做垃圾回收工作</span><br><span class="line">2.一般设置成70%左右</span><br></pre></td></tr></table></figure>

<p><strong>案例调优</strong></p>
<ul>
<li>案例1 Full GC 和 Minor GC频繁</li>
<li>案例2请求高峰期发生 Full GC，单次暂停时间特别长 (CMS)</li>
<li>案例;老年代充裕情况下，发生 Full GC (1.7)</li>
</ul>
<p>案例1:</p>
<p>分析原因，是新生代空间不足，导致幸存区占满，然后jvm动态调整晋升阈值，使得老年代存放许多临时的对象，老年代占满后又触发fullGc。</p>
<p>解决：增加新生代空间大小，加大晋升阈值</p>
<p>案例2:</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220725163555413.png" alt="image-20220725163555413" loading="lazy"></p>
<p>初始标记和并发标记时间是较短的，重新标记时间较长，因为重新标记需要对老年代扫描而且也会对新生代开始扫描，先对垃圾回收器的时间阶段统计出各阶段的时间，发现重新标记确实时间较长</p>
<p>-XX:+CMSScavengeBeforeRemark可以开启这个参数，使得重新标记前做一次新生代垃圾回收，使得重新标记的对象较少。</p>
<p>案例3:</p>
<p>jdk1.7方法区是永久代放在堆里，而1.8是元空间使用操作系统的内存，1.7方法区内存不足也会造成fullGc，增大永久代的内存空间</p>
<p><strong>曾经出现的内存泄露问题</strong></p>
<p>做安卓app时定义了一个static List 不断 存放添加进来的地图点信息。导致内存泄漏，app强退。</p>
<p>业务需求：添加时判断是否重复添加或者错误信息，并且将所有采集的数据显示在地图上。</p>
<p>解决：将业务判断等放在后端处理，调接口传数据就行，并且只展示当次采集的数据。</p>
<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Javac -parameters -d . Hellowworld.java 编译成字节码文件</span><br></pre></td></tr></table></figure>

<p><strong>JVM规范，类文件结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">		u4								magic;           //魔术，4字节，cafebabe，表示它是否是class类型文件</span><br><span class="line">		u2								minor_version;   //版本，4-7字节，00000034，16进制为52表示java8，53表示java9 </span><br><span class="line">		u2								major_version;	 </span><br><span class="line">		u2								constant_pool_count；//常量池长度，8-9字节，0023(35)表示常量池有#1~#34项，#0项不计入</span><br><span class="line">		cpinfo 						constant_pool[constant_pool_count-1]；</span><br><span class="line">		u2								access_flags;			//访问标识，public/private等</span><br><span class="line">		u2								this class；			 //在常量池中找本类全限定名</span><br><span class="line">		u2								super_class；		 //在常量池中找父类全限定名</span><br><span class="line">		u2								interfaces_count；//接口数量</span><br><span class="line">		u2								interfaces[interfaces_count〕;</span><br><span class="line">		u2								field info				//Field类型</span><br><span class="line">		u2								fields_count；		 //Field数量</span><br><span class="line">		u2								fields [fields_count ]；</span><br><span class="line">		u2								methods count;    //方法数量</span><br><span class="line">    method info				methods Imethods _count];//方法信息：方法修饰类型，常量池中的名称等</span><br><span class="line">		u2								attributes_count; //附加数量</span><br><span class="line">		attribute info 		attributes[attributes_count]；//附加属性信息</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html 官网java8虚拟机规范</span><br></pre></td></tr></table></figure>


<h2 id="字节码解释init"><a href="#字节码解释init" class="headerlink" title="字节码解释init"></a>字节码解释init</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2a b7 00 01 b1</span><br><span class="line"></span><br><span class="line">this.init();//init=代表构造方法</span><br><span class="line">1. 2a:aload_0,即this</span><br><span class="line">2. b7:invokespecial预备调用构造方法</span><br><span class="line">3. 00 01:引用常量池中#1项，即【Method java/lang/Object.“&lt;init&gt;”:()V】</span><br><span class="line">4. b1:表示返回</span><br></pre></td></tr></table></figure>

<h2 id="字节码解释输出语句"><a href="#字节码解释输出语句" class="headerlink" title="字节码解释输出语句"></a>字节码解释输出语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b2 00 02 12 03 b6 00 04 b1</span><br><span class="line"></span><br><span class="line">System.out  &quot;hello world&quot;  .println(String)V</span><br><span class="line">1. b2:getstatic 加载静态变量</span><br><span class="line">2. 00 02:引用常量池中的#2项，即【Field java/lang/System.out:Ljava/io/PrintStream;】</span><br><span class="line">3. 12:ldc加载常数</span><br><span class="line">4. 03：引用常量池中#3项，即【String hello world】</span><br><span class="line">5. b6:invokevirtual 预备调用成员方法</span><br><span class="line">6. 00 04:引用常量池中#4项，即【Method java/io/PrintStream.printLn:(Ljava/lang/String;)V】</span><br><span class="line">7. b1:表示返回</span><br><span class="line">注意：字节码指令中顺序是先方法名，参数，然后调用方法</span><br></pre></td></tr></table></figure>

<h2 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h2><p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javap -v Hellolorld.class</span><br><span class="line">-v：输出类文件的详细信息</span><br></pre></td></tr></table></figure>

<h2 id="从字节码角度分析赋值"><a href="#从字节码角度分析赋值" class="headerlink" title="从字节码角度分析赋值"></a>从字节码角度分析赋值</h2><ul>
<li>字节码中常量池放入运行时常量池（short最大值以下直接在Code中，不进入常量池）</li>
<li>字节码的Code方法加载入方法区</li>
<li>main 线程开始运行，分配栈帧内存（局部变量表，最大操作数栈）</li>
</ul>
<p><img src="http://hexo.xuxin.world/hexo/image-20220726161153283.png" alt="image-20220726161153283" loading="lazy"></p>
<p><strong>bipush 10</strong></p>
<ul>
<li>将一个 byte 压入操作数栈（其长度会补齐4个字节），类似的指令还有</li>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐4个字节）</li>
<li>lde 将一个 int 压入操作数栈</li>
<li>Idc2w将一个 long 压入操作数栈（分两次压入，因为long 是8个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li>
</ul>
<img src="http://hexo.xuxin.world/hexo/image-20220727163332706.png" alt="image-20220727163332706" style="zoom:67%;" / loading="lazy">

<p><strong>Istore_1</strong></p>
<p>将操作数栈顶数据弹出，存入局部变量表的 slot</p>
<img src="http://hexo.xuxin.world/hexo/image-20220727163451368.png" alt="image-20220727163451368" style="zoom: 33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220727163506964.png" alt="image-20220727163506964" style="zoom:33%;" / loading="lazy">

<p><strong>Idc #3</strong><br>从常量池加载#3数据到操作数栈<br>注意 Short.MAX_VALUE 是32767，所以32768： -Short.MAX_VALUE+1实际是在编译期间计算好的</p>
<img src="http://hexo.xuxin.world/hexo/image-20220727163805434.png" alt="image-20220727163805434" style="zoom: 33%;" / loading="lazy">

<p><strong>iload_1</strong></p>
<p>将临时变量表中数据放入操作数栈中</p>
<img src="http://hexo.xuxin.world/hexo/image-20220727164017707.png" alt="image-20220727164017707" style="zoom: 33%;" / loading="lazy">

<p><strong>iadd</strong></p>
<p>会将操作数栈的俩个值弹出，计算，将结果放入操作数栈中</p>
<img src="http://hexo.xuxin.world/hexo/image-20220727164232682.png" alt="image-20220727164232682" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220727164251197.png" alt="image-20220727164251197" style="zoom:33%;" / loading="lazy">

<p><strong>getstatic #4</strong></p>
<p>通过常量池找到堆中的对象，将对象的引用放入操作数栈中</p>
<img src="http://hexo.xuxin.world/hexo/image-20220727164622673.png" alt="image-20220727164622673" style="zoom:33%;" / loading="lazy">

<p><strong>invokevirtual #5</strong></p>
<ul>
<li>找到常量池#5 项</li>
<li>定位到方法区 java/io/PrintStream.printin：（I)V 方法</li>
<li>生成新的栈帧（分配 locals、 stack等）</li>
<li>传递参数，执行新栈帧中的字节码</li>
</ul>
<img src="http://hexo.xuxin.world/hexo/image-20220727165014132.png" alt="image-20220727165014132" style="zoom:33%;" / loading="lazy">

<ul>
<li>执行完毕，弹出栈帧</li>
<li>清除 main 操作数栈内容</li>
</ul>
<img src="http://hexo.xuxin.world/hexo/image-20220727165105944.png" alt="image-20220727165105944" style="zoom:33%;" / loading="lazy">

<p><strong>Teturn</strong></p>
<ul>
<li>完成 main 方法调用，弹出 main 栈帧</li>
<li>程序结束</li>
</ul>
<h2 id="从字节码角度分析a"><a href="#从字节码角度分析a" class="headerlink" title="从字节码角度分析a++"></a>从字节码角度分析a++</h2><ul>
<li>注意 iinc 指令是直接在局部变量 slot 上进行运算</li>
<li>a++和++a 的区别是先执行 iload 还是先执行 inc</li>
</ul>
<img src="http://hexo.xuxin.world/hexo/image-20220727165620095.png" alt="image-20220727165620095" style="zoom:25%;" / loading="lazy">

<p>a++</p>
<img src="http://hexo.xuxin.world/hexo/image-20220727165819421.png" alt="image-20220727165819421" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220727165956964.png" alt="image-20220727165956964" style="zoom:33%;" / loading="lazy">

<p>++a</p>
<img src="http://hexo.xuxin.world/hexo/image-20220727170052203.png" alt="image-20220727170052203" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220727170111008.png" alt="image-20220727170111008" style="zoom:33%;" / loading="lazy">

<h2 id="从字节码角度分析流程控制"><a href="#从字节码角度分析流程控制" class="headerlink" title="从字节码角度分析流程控制"></a>从字节码角度分析流程控制</h2><img src="http://hexo.xuxin.world/hexo/image-20220727170623468.png" alt="image-20220727170623468" style="zoom:25%;" / loading="lazy">

<ul>
<li>byte， short，char 都会按 int 比较，因为操作数栈都是4 字节</li>
<li>而long等类型则先lcmp，再ifne</li>
<li>根据比较结果用goto 来进行跳转到指定行号的字节码</li>
</ul>
<p>源码</p>
<img src="http://hexo.xuxin.world/hexo/image-20220727170752929.png" alt="image-20220727170752929" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220727170825185.png" alt="image-20220727170825185" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220727172308630.png" alt="image-20220727172308630" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220727172323441.png" alt="image-20220727172323441" style="zoom: 33%;" / loading="lazy">

<h2 id="从字节码分析x-0"><a href="#从字节码分析x-0" class="headerlink" title="从字节码分析x=0"></a>从字节码分析x=0</h2><img src="http://hexo.xuxin.world/hexo/image-20220727172821946.png" alt="image-20220727172821946" style="zoom:33%;" / loading="lazy">

<h2 id="从字节码分析cinit"><a href="#从字节码分析cinit" class="headerlink" title="从字节码分析cinit"></a>从字节码分析cinit</h2><p>字节码指令将所有静态会被合并成一个cinit方法，从上至下顺序cinit()V会在类加载的初始化阶段被调用</p>
<img src="http://hexo.xuxin.world/hexo/image-20220728155250306.png" alt="image-20220728155250306" style="zoom: 50%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728155400364.png" alt="image-20220728155400364" style="zoom:33%;" / loading="lazy">

<h2 id="从字节码分析init"><a href="#从字节码分析init" class="headerlink" title="从字节码分析init"></a>从字节码分析init</h2><p>编译器会按从上至下的顺序，收集所有代码块和成员变量赋值的代码，形成新的构造方法，但原始构造<br>方法内的代码总是在最后</p>
<img src="http://hexo.xuxin.world/hexo/image-20220728155940787.png" alt="image-20220728155940787" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728155923536.png" alt="image-20220728155923536" style="zoom:33%;" / loading="lazy">

<h2 id="从字节码分析方法调用"><a href="#从字节码分析方法调用" class="headerlink" title="从字节码分析方法调用"></a>从字节码分析方法调用</h2><p>init，private和static都是确定的，在编译阶段就能被确定，直接就能找到方法的地址，而public可能被重写，所以动态绑定，运行期间确定，需要查找多次</p>
<p>new 在堆中开辟一块空间给对象，将对象的引用放入操作数栈</p>
<p>dup 复制一份最上面的在操作数栈</p>
<p>使用实例对象调用静态方法会产生不必要的指令，aload_1和pop，因为静态方法的调用不需要实例</p>
<img src="http://hexo.xuxin.world/hexo/image-20220728160838675.png" alt="image-20220728160838675" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728160817007.png" alt="image-20220728160817007" style="zoom:33%;" / loading="lazy">

<h2 id="从字节码分析多态"><a href="#从字节码分析多态" class="headerlink" title="从字节码分析多态"></a>从字节码分析多态</h2><p>当执行 invokevirtual 指令时</p>
<ul>
<li>先通过栈帧中的对象引用找到对象</li>
<li>分析对象头，找到对象的实际 Class</li>
<li>Class 结构中有 vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查表得到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h2 id="从字节码分析异常处理"><a href="#从字节码分析异常处理" class="headerlink" title="从字节码分析异常处理"></a>从字节码分析异常处理</h2><img src="http://hexo.xuxin.world/hexo/image-20220728163521477.png" alt="image-20220728163521477" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728163454476.png" alt="image-20220728163454476" style="zoom:33%;" / loading="lazy">

<p>可以看到多出来一个 Exception table 的结构，[from,to）是前闭后开的检测范围，一旦这个范围内的字节码<br>执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号<br>8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置</p>
<p><strong>finally</strong></p>
<p>字节码指令中会分成3份，try，catch和发生其他异常，每一份都会在结尾加上finally，此时异常表中会额外多出一份其他异常，监听try和catch，当发生其他异常时会走第三份字节码指令。</p>
<img src="http://hexo.xuxin.world/hexo/image-20220728164442556.png" alt="image-20220728164442556" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728164405696.png" alt="image-20220728164405696" style="zoom:33%;" / loading="lazy">

<p><strong>finally中return</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220728165213010.png" alt="image-20220728165213010" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728165153568.png" alt="image-20220728165153568" style="zoom:33%;" / loading="lazy">

<p>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准</p>
<p>finally中return会吞掉throw，即使try中有异常也不会报错，很危险⚠️</p>
<p><strong>解读istore_0</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220728165843690.png" alt="image-20220728165843690" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728165906682.png" alt="image-20220728165906682" style="zoom:33%;" / loading="lazy">

<p>return后面有值会将返回值暂存新的槽位固定返回值，最后再弹出，而finally的语句不影响这个新的槽位</p>
<h2 id="从字节码分析syn"><a href="#从字节码分析syn" class="headerlink" title="从字节码分析syn"></a>从字节码分析syn</h2><p>为什么synchronized代码块中出现了异常，会解锁？</p>
<p>利用了异常表，会监听正常流程，以及解锁过程异常也会重复执行解锁</p>
<p>方法级别的 synchronized 不会在字节码指令中有所体现</p>
<img src="http://hexo.xuxin.world/hexo/image-20220728171152614.png" alt="image-20220728171152614" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728171132935.png" alt="image-20220728171132935" style="zoom:33%;" / loading="lazy">

<h1 id="编译期处理"><a href="#编译期处理" class="headerlink" title="编译期处理"></a>编译期处理</h1><p>所谓的 语法糖，其实就是指 java 编译器把*.java 源码编译为*.class 字节码的过程中，自动生成和转换的<br>一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛）</p>
<p> 注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件jclasslib 等工具。另外，编译器转<br>换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会<br>转换出中间的java 源码，切记。</p>
<h3 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h3><p><img src="http://hexo.xuxin.world/hexo/image-20220728171930029.png" alt="image-20220728171930029" loading="lazy"></p>
<h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><p><img src="http://hexo.xuxin.world/hexo/image-20220728172144342.png" alt="image-20220728172144342" loading="lazy"></p>
<h3 id="范型擦除"><a href="#范型擦除" class="headerlink" title="范型擦除"></a>范型擦除</h3><p> <img src="http://hexo.xuxin.world/hexo/image-20220728172537845.png" alt="image-20220728172537845" loading="lazy"></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220728172506834.png" alt="image-20220728172506834" loading="lazy"></p>
<p>⚠️注意：擦除的是字节码上（code）的泛型信息，可以看到 LocalVariableType Table 局部变量类型表仍然保留了方法参数泛型的信息</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220728173154742.png" alt="image-20220728173154742" loading="lazy"></p>
<p><strong>获取范型的信息</strong></p>
<p>只能获取方法的范型参数和返回值的范型信息</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220728172958363.png" alt="image-20220728172958363" loading="lazy"></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p><img src="http://hexo.xuxin.world/hexo/image-20220728173439549.png" alt="image-20220728173439549" loading="lazy"></p>
<p>注意<br>如果调用了 foo() 则等价代码为 Too(new String[]{})，创建了一个空的数组，而不会传递 nul1 进去</p>
<h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><img src="http://hexo.xuxin.world/hexo/image-20220728173714430.png" alt="image-20220728173714430" style="zoom:33%;" / loading="lazy">

<p>集合的优化</p>
<img src="http://hexo.xuxin.world/hexo/image-20220728173837362.png" alt="image-20220728173837362" style="zoom:33%;" / loading="lazy">

<p>注意<br>foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用<br>来获取集合的迭代器 (Iterator)</p>
<h3 id="swithc字符串"><a href="#swithc字符串" class="headerlink" title="swithc字符串"></a>swithc字符串</h3><img src="http://hexo.xuxin.world/hexo/image-20220728174255057.png" alt="image-20220728174255057" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220728174210450.png" alt="image-20220728174210450" style="zoom:33%;" / loading="lazy">

<h3 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h3><img src="http://hexo.xuxin.world/hexo/image-20220729143308943.png" alt="image-20220729143308943" style="zoom:33%;" / loading="lazy">

 

<img src="http://hexo.xuxin.world/hexo/image-20220729143509759.png" alt="image-20220729143509759" style="zoom:33%;" / loading="lazy">

<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><img src="http://hexo.xuxin.world/hexo/image-20220729143818352.png" alt="image-20220729143818352" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220729143831642.png" alt="image-20220729143831642" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220729143856497.png" alt="image-20220729143856497" style="zoom:33%;" / loading="lazy">

<h3 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h3><img src="http://hexo.xuxin.world/hexo/image-20220729144034576.png" alt="image-20220729144034576" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220729144137658.png" alt="image-20220729144137658" style="zoom:33%;" / loading="lazy">

<h3 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h3><img src="http://hexo.xuxin.world/hexo/image-20220729144858153.png" alt="image-20220729144858153" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220729144925508.png" alt="image-20220729144925508" style="zoom:33%;" / loading="lazy">

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><img src="http://hexo.xuxin.world/hexo/image-20220729145322688.png" alt="image-20220729145322688" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220729145347804.png" alt="image-20220729145347804" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220729145414091.png" alt="image-20220729145414091" style="zoom:33%;" / loading="lazy">

 

<img src="http://hexo.xuxin.world/hexo/image-20220729145302263.png" alt="image-20220729145302263" style="zoom:33%;" / loading="lazy">

<h1 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h1><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><ul>
<li>将类的字节码载入方法区中，內部采用 C++ 的 instanceKlass 描述java 类，它的重要 field 有：</li>
<li><ul>
<li><strong>_ java_ miror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴露给 java 使用</strong></li>
<li><strong>_super 即父类</strong></li>
<li><strong>_fields 即成员变量</strong></li>
<li><strong>_methods 即方法</strong></li>
<li><strong>_constants 即常量池</strong></li>
<li><strong>_ class_ loader 即类加载器</strong></li>
<li><strong>_vtable 虚方法表</strong></li>
<li><strong>_itable 接口方法表</strong></li>
</ul>
</li>
<li>如果这个类还有父类没有加载，先加载父类</li>
<li>加载和链接可能是交替运行的</li>
</ul>
<img src="http://hexo.xuxin.world/hexo/image-20220729150047364.png" alt="image-20220729150047364" style="zoom:33%;" / loading="lazy">

<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><ul>
<li>验证：验证类是否符合JVM规范，安全性检查</li>
<li>准备：为 static 变量分配空间，设置默认值<ul>
<li>static 变量在JDK 7 之前存储于 instanceKlass 末尾，从JDK 7开始，存储于_java_ mirror 末尾</li>
<li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成,「赋值在初始化阶段（cinit）完成</li>
<li>如果 static 变量是 final 的基本类型和String的“ ”，那么编译阶段值就确定了，赋值在准备阶段完成</li>
<li>如果 static 变量是 final 的，但属于引用类型和String的new，那么赋值也会在初始化阶段完成</li>
</ul>
</li>
<li>解析：将常量池中的符号引用解析为直接引用<ul>
<li>加载器的loadclass 方法不会导致类的解析和初始化</li>
<li>而new()则会解析和初始化</li>
</ul>
</li>
</ul>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p><strong>初始化即调用 <cinit>()v，虚拟机会保证这个类的『构造方法』的线程安全</strong></p>
<p><strong>概括得说，类初始化是【懒情的】</strong></p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p><strong>不会导致类初始化的情况</strong></p>
<ul>
<li>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类的数组不会触发初始化</li>
<li>•类加载器的 loadclass 方法</li>
<li>Class.forName 的参数2为 false 时</li>
</ul>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul>
<li>启动类加载</li>
<li>扩展类加载器</li>
<li>应用程序类加载</li>
<li>自定义类加载</li>
</ul>
<p><img src="http://hexo.xuxin.world/hexo/image-20220801172651812.png" alt="image-20220801172651812" loading="lazy"></p>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p><img src="http://hexo.xuxin.world/hexo/image-20220801173205299.png" alt="image-20220801173205299" loading="lazy"></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220801173108680.png" alt="image-20220801173108680" loading="lazy"></p>
<p>打印结果是null说明是启动类加载器，因为它是c++写的，java无法直接访问</p>
<h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则</p>
<p>先查扩展类加载器，没有则找启动类加载器，如果还没有则走应用程序加载器</p>
<h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><p>线程上下文类加载器是在线程启动时jvm默认将应用程序类加载器给线程</p>
<p><strong>SPI</strong></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220802092226748.png" alt="image-20220802092226748" loading="lazy"></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220802092505054.png" alt="image-20220802092505054" loading="lazy"></p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>类一样的定义：包名类名类加载器一样</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220802093004132.png" alt="image-20220802093004132" loading="lazy"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Load extends ClassLoader &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String path = &quot;/Users/xuxin/workspace/jvm/out/production/ClassLoad/&quot;+name+&quot;.class&quot;;</span><br><span class="line">            ByteArrayOutputStream os = new ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path), os);</span><br><span class="line">            byte[] bytes = os.toByteArray();</span><br><span class="line">            return defineClass(name, bytes, 0, bytes.length);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new ClassNotFoundException(&quot;类文件未找到&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h1><p><img src="http://hexo.xuxin.world/hexo/image-20220802100709406.png" alt="image-20220802100709406" loading="lazy"></p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>jvm参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation -XX:-DoEscapeAnalysis  #关闭逃逸分析</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 200; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">        new Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当循环内的对象在外部没有引用时，c2即时编译期会将这段代码替换成空，不执行。</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p><img src="http://hexo.xuxin.world/hexo/image-20220802101818902.png" alt="image-20220802101818902" loading="lazy"></p>
<p>jvm参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining #打印内联情况 </span><br><span class="line">-XX:CompileCommand=dontinline,*JI72.squar   #禁用指定方法内联</span><br><span class="line">-XX:+PrintCompilation</span><br></pre></td></tr></table></figure>

<h3 id="字段优化"><a href="#字段优化" class="headerlink" title="字段优化"></a>字段优化</h3><img src="http://hexo.xuxin.world/hexo/image-20220802102849510.png" alt="image-20220802102849510" style="zoom:33%;" / loading="lazy">

<p>方法是否内联影响其中字段成员的读取的优化</p>
<img src="http://hexo.xuxin.world/hexo/image-20220802103129532.png" alt="image-20220802103129532" style="zoom:33%;" / loading="lazy">

<p>方法一如果内联会在机器码层面缓存一个local[]，从而减少1999次的Field读取</p>
<p>方法二则手动在内存里缓存了，相当于将机器码层面的缓存一样的效果</p>
<p>方法三则底层是方法二</p>
<h3 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h3><p>当反射调用方法时，会使用本地方法访问器来invoke。但当访问15次时候会由运行期动态生成的方法访问器。内部直接调用方法，而不是反射调用了</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220802104146595.png" alt="image-20220802104146595" loading="lazy"></p>
<h1 id="内存模型JMM"><a href="#内存模型JMM" class="headerlink" title="内存模型JMM"></a>内存模型JMM</h1><p>简单的说，JMM定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、<br>和原子性的规则和保障</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>问题提出，两个线程对初始值为0的静态变量一个做自增，一个做自减，各做 5000 次，结果是0吗？</p>
<img src="http://hexo.xuxin.world/hexo/image-20220802165659272.png" alt="image-20220802165659272" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220802165615796.png" alt="image-20220802165615796" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220802165537556.png" alt="image-20220802165537556" style="zoom: 50%;" / loading="lazy">

<p><strong>解决</strong></p>
<p>原子性靠synchronized来解决</p>
<p>锁对象的粒度要大一点，来减少不必要的重复加锁</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>由于JIT优化引起的，会在工作内存中创建一个高速缓存</p>
<img src="http://hexo.xuxin.world/hexo/image-20220802165501687.png" alt="image-20220802165501687" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220802165413054.png" alt="image-20220802165413054" style="zoom: 33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220802165400043.png" alt="image-20220802165400043" style="zoom:33%;" / loading="lazy">

<img src="http://hexo.xuxin.world/hexo/image-20220802165346905.png" alt="image-20220802165346905" style="zoom:33%;" / loading="lazy">

<p><strong>解决</strong></p>
<p>volatile（易变关键字）</p>
<ul>
<li>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存<br>中获取它的值，线程操作 volatile 变量都是直接操作主存</li>
<li>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线<br>程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况</li>
</ul>
<p>synchronized</p>
<ul>
<li>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synehronized是属于重量级操作，性能相对更低</li>
<li>但是如果在前面示例的死循环中加入 System.out.println0 会发现即使不加 volatile 修饰符，线程t也能正确看到对 run 变量的修改了，因为println中有synchronized，强制了线程走主内存获取</li>
</ul>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><img src="http://hexo.xuxin.world/hexo/image-20220802170855001.png" alt="image-20220802170855001" style="zoom:33%;" / loading="lazy">

<p>可能ready = true执行，r.r1 = num+num;执行，最后num = 2执行。</p>
<p>这种现象叫做指令重排，是JT编译器在运行时的一些优化，这个现象需要通过大量测试才能复现</p>
<p><strong>解决</strong></p>
<p>在可读可写的ready上添加关键字volatile，来禁用指令重排</p>
<p><strong>volatile 字段禁止指令重排序的底层原理</strong></p>
<p>以 volatile 字段访问为例，所插入的内存屏障将不允许 volatile 字段写操作之前的内存访问被重排序至其之后；</p>
<p>也将不允许 volatile 字段读操作之后的内存访问被重排序至其之前。</p>
<p><strong>内存屏障（memory barrier）</strong><br>对于即时编译器来说，它会针对前面提到的每一个 happens-before 关系，向正在编译的目标方法中插入相应的读读、读写、写读以及写写内存屏障。</p>
<p>这些内存屏障会限制即时编译器的重排序操作。</p>
<p>即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。</p>
<p>以我们日常接触的 X86_64 架构来说，读读、读写以及写写内存屏障是空操作（no-op），只有写读内存屏障会被替换成具体指令。</p>
<p>对于即时编译器来说，内存屏障将限制它所能做的重排序优化。对于处理器来说，内存屏障会导致缓存的刷新操作。</p>
<p><strong>指令重排</strong></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220802171700106.png" alt="image-20220802171700106" loading="lazy"></p>
<p>双重检查锁的单例存在的问题</p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220802172406810.png" alt="image-20220802172406810" loading="lazy"></p>
<img src="http://hexo.xuxin.world/hexo/image-20220802172439921.png" alt="image-20220802172439921" style="zoom:33%;" / loading="lazy">

<p><strong>解决</strong></p>
<p>对INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在JDK 5 以上的版本的 volatile 才会真<br>正有效</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><ul>
<li>解锁操作 happens-before 之后（这里指时钟顺序先后）对同一把锁的加锁操作。</li>
<li>volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。</li>
<li>线程的启动操作（即 Thread.starts()） happens-before 该线程的第一个操作。</li>
<li>线程的最后一个操作 happens-before 它的终止事件（即其他线程通过 Thread.isAlive() 或 Thread.join() 判断该线程是否中止）。</li>
<li>线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。</li>
<li>构造器中的最后一个操作 happens-before 析构器的第一个操作。</li>
</ul>
<p><strong>线程解锁 m 之前对变量的写，对于接下来对m 加锁的其它线程对该变量的读可见</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220802173449212.png" alt="image-20220802173449212" style="zoom:33%;" / loading="lazy">

<p><strong>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220802174926482.png" alt="image-20220802174926482" style="zoom: 50%;" / loading="lazy">

<p><strong>线程 start 前对变量的写，对该线程开始后对该变量的读可见</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220802175026940.png" alt="image-20220802175026940" style="zoom:50%;" / loading="lazy">

<p><strong>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 tlL.isAlive0 或 t1.join0等</strong><br><strong>待它结束）</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220802175126712.png" alt="image-20220802175126712" style="zoom:50%;" / loading="lazy">

<p><strong>线程 tl打断 t2 (interrupt) 前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted)</strong></p>
<img src="http://hexo.xuxin.world/hexo/image-20220802175230071.png" alt="image-20220802175230071" style="zoom:50%;" / loading="lazy">

<p><strong>对变量默认值(0，false，null）的写，对其它线程对该变量的读可见</strong><br><strong>具有传递性，如果xhb-&gt;y并且yhb-&gt;Z那么有xhb-&gt;z</strong></p>
<h1 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h1><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><img src="http://hexo.xuxin.world/hexo/image-20220803135702332.png" alt="image-20220803135702332" loading="lazy"></p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>CAS它的功能是判断内存某个位置的值是否为预期值，底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS指令，它是一条并发原语。</p>
<p>CAS 并发原语体现在 Java 语言中就是 sun.misc.Unsafe 类中的各个方法。调用 Unsafe 类中的 CAS 方法，JVM 会帮我们实现 CAS 汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作，再次强调，由于CAS 是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许中断，也就是说 CAS 是一条原子指令，不会造成所谓的数据不一致的问题。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>jue (java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：Atomicinteger<br>AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    private static AtomicInteger i = new AtomicInteger(0);</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (int j = 0; j &lt; 5000; j++) &#123;</span><br><span class="line">                i.getAndIncrement();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = new Thread(()-&gt;&#123;</span><br><span class="line">            for (int j = 0; j &lt; 5000; j++) &#123;</span><br><span class="line">                i.getAndDecrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><p>HotSpot<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>Java Hotspot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark word)。Mark word 平时存储这个对<br>象的 哈希码、分代年龄，当加锁时，这些信息就根据情况被替换为 标记位、线程锁记录指针、重量级锁指针、线<br>程ID等内容</p>
<p><strong>轻量级锁</strong></p>
<p>加锁：每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word，加轻量锁时，栈帧里存MarkWord，并将对象头改为标识符+引用地址，标识符01-&gt;00标识轻量锁，过程用CAS来更改</p>
<p>解锁：栈帧记录的对象头还原，用CAS来更改，因为如果失败说明轻量锁升级为重量锁了</p>
<p><strong>锁膨胀</strong></p>
<p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情,况就是有其它线程为此对象加上了轻量级<br>锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<p><strong>重量级锁自旋</strong></p>
<p>重量级锁加锁：访问同步块获取monitor，将对象头设置10+地址</p>
<p>自旋：当获取锁失败，会不断自旋重试，获取成功，但是如果长时间没有获取成功，则阻塞</p>
<p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。<br>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。<br>好比等红灯时汽车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阳塞（等待时间<br>长了划算）</p>
<p><strong>偏向锁</strong></p>
<p><img src="http://hexo.xuxin.world/hexo/image-20220803151836823.png" alt="image-20220803151836823" loading="lazy"></p>
<p><strong>其他优化</strong></p>
<p><strong>1.减少上锁时间</strong><br>同步代码块中尽量短</p>
<p><strong>2.减少锁的粒度</strong><br>将一个锁拆分为多个锁提高并发度，例如：<br>ConcurrentHashMap<br>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell累加，再加上 base 就是最终的值<br>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</p>
<img src="http://hexo.xuxin.world/hexo/image-20220803153022260.png" alt="image-20220803153022260" style="zoom: 50%;" / loading="lazy">

<p><strong>5读写分离</strong></p>
<p>CopyOnWriteArrayList<br>ConyOn WriteSet</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><span class="icon iconify" data-icon="ri:hand-coin-line"></span></span><div id="reward-comment">I'm so cute. Please give me money.</div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>徐鑫</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2022/08/05/JVM/JVM/" title="JVM">http://example.com/2022/08/05/JVM/JVM/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/08/08/JUC/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="prev" title="JUC并发编程"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">JUC并发编程</span></a></div><div class="post-nav-item"></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> 徐鑫</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></body></html>